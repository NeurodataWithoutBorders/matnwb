classdef DynamicTableTest < tests.system.RoundTripTest & tests.system.AmendTest
    methods
        function addContainer(~, file)
            colnames = {'start_time', 'stop_time', 'randomvalues', 'random_multi', 'stringdata'};
            %add trailing nulls to columnames
            for c =1:length(colnames)
                colnames{c} = char([double(colnames{c}) zeros(1,randi(10))]);
            end
            file.intervals_trials = types.core.TimeIntervals(...
                'description', 'test dynamic table column',...
                'colnames', colnames);
            
            id = primes(2000) .';
            for i = 1:100
                file.intervals_trials.addRow(...
                    'start_time', i,...
                    'stop_time', i+1,...
                    'randomvalues', {rand(5,2);rand(3,2)},...
                    'random_multi', rand(1,3,2),...
                    'stringdata', {'TRUE'},...
                    'id', id(i));
            end
            % test adding table without id's specified 
            file.intervals_trials.addRow(table(...
                (101:150) .',...
                (102:151) .',...
                mat2cell(rand(250,2), repmat(5, 50, 1)),...
                rand(50,3,2),...
                repmat({'TRUE'}, 50, 1),...
                'VariableNames', {'start_time', 'stop_time', 'randomvalues', 'random_multi','stringdata'}));
            %test adding table with id's specified 
            file.intervals_trials.addRow(table(...
                id(151:200),...
                (151:200) .',...
                (152:201) .',...
                mat2cell(rand(250,2), repmat(5, 50, 1)),...
                rand(50,3,2),...
                repmat({'TRUE'}, 50, 1),...
                'VariableNames', {'id', 'start_time', 'stop_time', 'randomvalues', 'random_multi', 'stringdata'}));
        end
        
        function addExpandableDynamicTable(~, file, start_array, stop_array, ...
                random_array, random_multi_array, id_array)
            % create VectorData objects with DataPipe objects
            start_time_exp = types.hdmf_common.VectorData( ...
                'description', 'start times', ...
                'data', types.untyped.DataPipe( ...
                    'data', start_array', ...
                    'maxSize', [Inf, 1], ...
                    'axis', 1 ...
                ) ...
            );
            stop_time_exp = types.hdmf_common.VectorData( ...
                'description', 'stop times', ...
                'data', types.untyped.DataPipe( ...
                    'data', stop_array', ...
                    'maxSize', [Inf, 1], ...
                    'axis', 1 ...
                ) ...
            );
            random_exp = types.hdmf_common.VectorData( ...
                'description', 'random data column', ...
                'data', types.untyped.DataPipe( ...
                    'data', random_array, ...
                    'maxSize', [Inf, 1], ...
                    'axis', 1 ...
                )...
            );
            random_multi_exp = types.hdmf_common.VectorData( ...
                'description', 'random data column', ...
                'data', types.untyped.DataPipe( ...
                    'data', random_multi_array, ...
                    'maxSize', [Inf, 3 , 2], ...
                    'axis', 1 ...
                )...
            );
            ids_exp = types.hdmf_common.ElementIdentifiers( ...
                'data', types.untyped.DataPipe( ...
                    'data', id_array', ... 
                    'maxSize', [Inf, 1], ...
                    'axis', 1 ...
                    ) ...
            );
            % create expandable table
            colnames = { ...
                'start_time', 'stop_time', ...
                'randomvalues', 'random_multi' ...
            };
           file.intervals_trials = types.core.TimeIntervals( ...
                'description', 'test expdandable dynamic table', ...
                'colnames', colnames, ...
                'start_time', start_time_exp, ...
                'stop_time', stop_time_exp, ...
                'randomvalues', random_exp, ...
                'random_multi', random_multi_exp, ...
                'id', ids_exp ...
            );    
        end
        
        function addContainerUnevenColumns(~, file)
            % create and add a container with columns of unmatched length
            colnames = {'start_time', 'stop_time', 'randomvalues'};
            file.intervals_trials = types.core.TimeIntervals(...
                'description', 'test dynamic table column',...
                'colnames', colnames, ...
                'start_time',  types.hdmf_common.VectorData( ...
                    'description', 'start time column', ...
                    'data', (1:200)' ...
                    ), ...
                'stop_time',  types.hdmf_common.VectorData( ...
                    'description', 'stop time column', ...
                    'data', (2:101)' ...
                    ), ...
                 'randomvalues',  types.hdmf_common.VectorData( ...
                    'description', 'randomvalues column', ...
                    'data', mat2cell(rand(250,2), repmat(5, 50, 1)) ...
                    ) ...
                );
        end
        function addContainerUnmatchedIDs(~, file)
            % create and add a container with columns of unmatched length
            colnames = {'start_time', 'stop_time', 'randomvalues'};
            file.intervals_trials = types.core.TimeIntervals(...
                'description', 'test dynamic table column',...
                'id',  types.hdmf_common.ElementIdentifiers( ...
                    'data', (0:48)' ...
                    ), ...
                'colnames', colnames, ...
                'start_time',  types.hdmf_common.VectorData( ...
                    'description', 'start time column', ...
                    'data', (1:50)' ...
                    ), ...
                'stop_time',  types.hdmf_common.VectorData( ...
                    'description', 'stop time column', ...
                    'data', (2:51)' ...
                    ), ...
                 'randomvalues',  types.hdmf_common.VectorData( ...
                    'description', 'randomvalues column', ...
                    'data', mat2cell(rand(250,2), repmat(5, 50, 1)) ...
                    ) ...
                );
        end
        function addContainerUndefinedIDs(~, file)
            % create and add a container with undefined id field
            colnames = {'start_time', 'stop_time', 'randomvalues'};
            file.intervals_trials = types.core.TimeIntervals(...
                'description', 'test dynamic table column',...
                'colnames', colnames, ...
                'start_time',  types.hdmf_common.VectorData( ...
                    'description', 'start time column', ...
                    'data', (1:50)' ...
                    ), ...
                'stop_time',  types.hdmf_common.VectorData( ...
                    'description', 'stop time column', ...
                    'data', (2:51)' ...
                    ), ...
                 'randomvalues',  types.hdmf_common.VectorData( ...
                    'description', 'randomvalues column', ...
                    'data', mat2cell(rand(250,2), repmat(5, 50, 1)) ...
                    ) ...
                );
        end
        function c = getContainer(~, file)
            c = file.intervals_trials.vectordata.get('randomvalues');
        end

        function appendContainer(testCase, file)
            container = testCase.getContainer(file);
            container.data = rand(1300, 2); % new random values.
            file.intervals_trials.vectordata.get('stringdata').data = repmat({'FALSE'}, 200, 1);
            %test adding new column with argument
            file.intervals_trials.addColumn( ...
                'newcolumn', types.hdmf_common.VectorData( ...
                    'description', 'newly added column', ...
                    'data', (200:-1:1) .' ...
                ) ...
           );
           %test adding new column set with table
           file.intervals_trials.addColumn( ...
               table( ...
                   (1:2:400) .', ...
                   (1:4:800) .', ...
                   'VariableNames', {'newcolumn2', 'newcolumn3'} ...
               ) ...
           );
        end
        function appendRaggedContainer(~, file)
            % create synthetic data
            data = (1000:-1:1);
            break_ind = [sort(randperm(999,199)) 1000];
            dataArray = cell(1,length(break_ind));
            startInd = 1;
             for i = 1:length(break_ind)
                 endInd = break_ind(i);
                 dataArray{i} = data(startInd:endInd);
                 startInd = endInd+1;
             end
             % get corresponding VectorData and VectorIndex
            [rag_col, rag_col_index] = util.create_indexed_column(dataArray);
            % append ragged column
            file.intervals_trials.addColumn( ...
                'newraggedcolumn',rag_col, ...
                'newraggedcolumn_index',rag_col_index ...
            )
        end
    end
    
    methods (Test)
        function getRowTest(testCase)
            Table = testCase.file.intervals_trials;

            BaseVectorData = Table.vectordata.get('randomvalues');
            VectorDataInd = Table.vectordata.get('randomvalues_index');
            VectorDataIndInd = Table.vectordata.get('randomvalues_index_index');

            endInd = VectorDataIndInd.data(5);
            startInd = VectorDataIndInd.data(4) + 1;

            Indices = startInd:endInd;
            dataIndices = cell(length(Indices),1);
            for iRaggedInd = 1:length(Indices)
                endInd = VectorDataInd.data(Indices(iRaggedInd));
                if 1 == Indices(iRaggedInd)
                    startInd = 1;
                else
                    startInd = VectorDataInd.data(Indices(iRaggedInd) - 1) + 1;
                end
                dataIndices{iRaggedInd} = BaseVectorData.data((startInd:endInd) .', :);
            end

            actualData = Table.getRow(5, 'columns', {'randomvalues'});
            testCase.verifyEqual(dataIndices, actualData.randomvalues{1});
            
            % test with appended ragged columns
            testCase.appendRaggedContainer(testCase.file)
            Table = testCase.file.intervals_trials;
            % retrieve ragged column and index
            BaseVectorData = Table.vectordata.get('newraggedcolumn');
            VectorDataInd = Table.vectordata.get('newraggedcolumn_index');
            % verify end of ragged column index equal length of data vector
            testCase.verifyEqual(length(BaseVectorData.data),double(VectorDataInd.data(end)))
            % get expected ragged data
            endInd = VectorDataInd.data(100);
            startInd = VectorDataInd.data(99) + 1;
            expectedData = BaseVectorData.data(startInd:endInd);
            % get actual ragged data
            actualData = Table.getRow(100);
            % compare
            testCase.verifyEqual(expectedData,actualData.newraggedcolumn{1})
        end

        function getRowRoundtripTest(testCase)
            filename = ['MatNWB.' testCase.className() '.testGetRow.nwb'];
            nwbExport(testCase.file, filename);
            ActualFile = nwbRead(filename, 'ignorecache');
            ActualTable = ActualFile.intervals_trials;
            ExpectedTable = testCase.file.intervals_trials;

            testCase.verifyEqual(ExpectedTable.getRow(5), ActualTable.getRow(5));
            testCase.verifyEqual(ExpectedTable.getRow([5 6]), ActualTable.getRow([5 6]));
            testCase.verifyEqual(ExpectedTable.getRow([1153, 1217], 'useId', true),...
                ActualTable.getRow([1153, 1217], 'useId', true));
        end
        
        function ExpandableTableTest(testCase)
            % define data matrices
            nrows = 200;
            id = 0:nrows-1;  % different from row poistion
            start_time_array = 1:nrows;
            stop_time_array = start_time_array + 1;
            rng(1);  % to be able replicate random values
            random_val_array = rand(nrows, 1);
            random_multi_array = rand(nrows, 3, 2);
            % create expandable table with first half of arrays
            testCase.addExpandableDynamicTable(testCase.file, ...
                start_time_array(1:100), stop_time_array(1:100), ...
                random_val_array(1:100), random_multi_array(1:100, : ,:), ...
                id(1:100));
            % export and read-in expandable table
            filename = ['MatNWB.' testCase.className() '.ExpandableTableTest.nwb'];
            nwbExport(testCase.file, filename);
            readFile = nwbRead(filename, 'ignorecache');
            % add rows to expandable table and export
            for i = 101:200
                readFile.intervals_trials.addRow( ...
                    'start_time', start_time_array(i), ...
                    'stop_time', stop_time_array(i), ...
                    'randomvalues', random_val_array(i), ...
                    'random_multi', random_multi_array(i, :, :), ...
                    'id', id(i) ...
                )
            end
            nwbExport(readFile, filename)
            % read in expanded table
            readFile = nwbRead(filename, 'ignorecache');
            % test getRow
            actualData = readFile.intervals_trials.getRow(1:200, ...
                'columns', {'randomvalues'});
            testCase.verifyEqual(random_val_array, actualData.randomvalues);
        end

        function toTableTest(testCase)
            % test DynamicTable toTable method. 
            % 1. For a generic table, the toTable output should be very
            % similar to getRow output (except for presence of id column)
            %
            % retrieve rows from dynamic table
            ExpectedSubTable = testCase.file.intervals_trials.getRow(1:200);
            % convert DynamicTable to MATLAB table
            TrialsTable = testCase.file.intervals_trials.toTable();
            TrialsTable.id = []; %remove id column
            % retrieve rows from MATLAB table
            ActualSubTable = TrialsTable(1:200,:);
            % compare
            testCase.verifyEqual(ExpectedSubTable,ActualSubTable)
            % 2. For a table with a DynamicTable regions, the toTable output 
            % with false index argument should return the rows of the
            % target DynamicTable.
            %
            % create table with DynamicTableRegion
            DTRCol = types.hdmf_common.DynamicTableRegion( ...
                'description', 'references rows of another table', ...
                'data', randi([0 199],100,1), ...  # 0-indexed
                'table',types.untyped.ObjectView(testCase.file.intervals_trials) ...  %
            );
            DataCol = types.hdmf_common.VectorData( ...
                'description', 'data column', ...
                'data', (1:100)' ...
            );
            DTRTable = types.hdmf_common.DynamicTable( ...
                'description', 'test table with DynamicTableRegion', ...
                'colnames', {'dtr_col','data_col'}, ...
                'dtr_col', DTRCol, ...
                'data_col',DataCol, ...
                'id', types.hdmf_common.ElementIdentifiers( ...
                    'data', (0:99)' ...
                ) ...
            );
            % convert DynamicTable to MATLAB table
            TrialsTableNoIndex = DTRTable.toTable(false);% include actual rows
            TrialsTableIndex = DTRTable.toTable(true);% include only index of rows
            % verify that the row included in DynamicTable and the
            % actual row indicated by the DynamicTableRegion are the same
            for i = 1:100
                testCase.verifyEqual( ...
                    testCase.file.intervals_trials.getRow( ...
                        TrialsTableIndex.dtr_col(i)+1 ... % must add 1 because DynamicTableRegion uses 0-indexing
                     ), ...
                     TrialsTableNoIndex.dtr_col{i} ...
                );
            end
        end

        function DynamicTableCheckTest(testCase)
            % Verify that the checkConfig utility function
            % throws error when defining an invalid table
            %
            % 1. Defining a table with columns of unmatched length
            testCase.verifyError( ...
                @() testCase.addContainerUnevenColumns(testCase.file), ...
                "NWB:DynamicTable" ...
            )

            % 2. Defining a table with length of id's does not match
            % the number of columns
            testCase.verifyError( ...
                @() testCase.addContainerUnmatchedIDs(testCase.file), ...
                "NWB:DynamicTable" ...
            )
             %3. Defining a table with unspecified IDs
             testCase.addContainerUndefinedIDs(testCase.file)
             Table = testCase.file.intervals_trials;
             % verify created IDs of same length as columns
             expectedLength = length(Table.start_time.data);
             actualLength = length(Table.id.data);
             testCase.verifyEqual(expectedLength, actualLength)
            
        end

    end
end

