<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>NWB File Conversion Tutorial</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-09-14">
<meta name="DC.source" content="convertTrials.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>NWB File Conversion Tutorial</h1>
<!--introduction-->
<p>How to convert trial-based experimental data to the Neurodata Without Borders file format using MatNWB. This example uses the <a href="https://crcns.org/data-sets/motor-cortex/alm-3">CRCNS ALM-3</a> data set. Information on how to download the data can be found on the <a href="https://crcns.org/data-sets/motor-cortex/download">CRCNS Download Page</a>. One should first familiarize themselves with the file format, which can be found on the <a href="https://crcns.org/data-sets/motor-cortex/alm-3/about-alm-3">ALM-3 About Page</a> under the Documentation files.</p>
<pre>author: Lawrence Niu
contact: lawrence@vidriotech.com
last updated: Sep 14, 2024</pre>
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Script Configuration</a>
</li>
<li>
<a href="#4">General Information</a>
</li>
<li>
<a href="#7">The ALM-3 File Structure</a>
</li>
<li>
<a href="#8">Metadata</a>
</li>
<li>
<a href="#15">Analysis Data Structure</a>
</li>
<li>
<a href="#16">Hashes</a>
</li>
<li>
<a href="#26">Raw Acquisition Data</a>
</li>
<li>
<a href="#27">Add timeseries to trials_epoch</a>
</li>
<li>
<a href="#28">Export</a>
</li>
</ul>
</div>
<h2 id="1">Script Configuration</h2>
<p>The following section describes configuration parameters specific to the publishing script, and can be skipped when implementing your own conversion. The parameters can be changed to fit any of the available sessions.</p>
<pre class="codeinput">animal = <span class="string">'ANM255201'</span>;
session = <span class="string">'20141124'</span>;

identifier = [animal <span class="string">'_'</span> session];

<span class="comment">% Specify the local path for the downloaded data:</span>
data_root_path = <span class="string">'data'</span>;

metadata_loc = fullfile(data_root_path, <span class="string">'metadata'</span>, [<span class="string">'meta_data_'</span> identifier <span class="string">'.mat'</span>]);
datastructure_loc = fullfile(data_root_path, <span class="string">'data_structure_files'</span>,<span class="keyword">...</span>
    [<span class="string">'data_structure_'</span> identifier <span class="string">'.mat'</span>]);
rawdata_loc = fullfile(data_root_path, <span class="string">'RawVoltageTraces'</span>, [identifier <span class="string">'.tar'</span>]);
</pre>
<p>The animal and session specifier can be changed with the <tt>animal</tt> and <tt>session</tt> variable name respectively.  <tt>metadata_loc</tt>, <tt>datastructure_loc</tt>, and <tt>rawdata_loc</tt> should refer to the metadata .mat file, the data structure .mat file, and the raw .tar file.</p>
<pre class="codeinput">output_directory = <span class="string">'out'</span>;

<span class="keyword">if</span> ~isfolder(output_directory)
    mkdir(output_directory);
<span class="keyword">end</span>

source_file = [mfilename() <span class="string">'.m'</span>];
[~, source_script, ~] = fileparts(source_file);
</pre>
<p>The NWB file will be saved in the output directory indicated by <tt>output_directory</tt>
</p>
<h2 id="4">General Information</h2>
<pre class="codeinput">nwb = NwbFile();
nwb.identifier = identifier;
nwb.general_source_script = source_script;
nwb.general_source_script_file_name = source_file;
nwb.general_lab = <span class="string">'Svoboda'</span>;
nwb.general_keywords = {<span class="string">'Network models'</span>, <span class="string">'Premotor cortex'</span>, <span class="string">'Short-term memory'</span>};
nwb.general_institution = [<span class="string">'Janelia Research Campus,'</span><span class="keyword">...</span>
    <span class="string">' Howard Huges Medical Institute, Ashburn, Virginia 20147, USA'</span>];
nwb.general_related_publications = <span class="keyword">...</span>
    [<span class="string">'Li N, Daie K, Svoboda K, Druckmann S (2016).'</span>,<span class="keyword">...</span>
    <span class="string">' Robust neuronal dynamics in premotor cortex during motor planning.'</span>,<span class="keyword">...</span>
    <span class="string">' Nature. 7600:459-64. doi: 10.1038/nature17643'</span>];
nwb.general_stimulus = <span class="string">'photostim'</span>;
nwb.general_protocol = <span class="string">'IACUC'</span>;
nwb.general_surgery = [<span class="string">'Mice were prepared for photoinhibition and '</span>,<span class="keyword">...</span>
    <span class="string">'electrophysiology with a clear-skull cap and a headpost. '</span>,<span class="keyword">...</span>
    <span class="string">'The scalp and periosteum over the dorsal surface of the skull were removed. '</span>,<span class="keyword">...</span>
    <span class="string">'A layer of cyanoacrylate adhesive (Krazy glue, Elmer''s Products Inc.) '</span>,<span class="keyword">...</span>
    <span class="string">'was directly applied to the intact skull. A custom made headpost '</span>,<span class="keyword">...</span>
    <span class="string">'was placed on the skull with its anterior edge aligned with the suture lambda '</span>,<span class="keyword">...</span>
    <span class="string">'(approximately over cerebellum) and cemented in place '</span>,<span class="keyword">...</span>
    <span class="string">'with clear dental acrylic (Lang Dental Jet Repair Acrylic; 1223-clear). '</span>,<span class="keyword">...</span>
    <span class="string">'A thin layer of clear dental acrylic was applied over the cyanoacrylate adhesive '</span>,<span class="keyword">...</span>
    <span class="string">'covering the entire exposed skull, '</span>,<span class="keyword">...</span>
    <span class="string">'followed by a thin layer of clear nail polish (Electron Microscopy Sciences, 72180).'</span>];
nwb.session_description = sprintf(<span class="string">'Animal `%s` on Session `%s`'</span>, animal, session);
</pre>
<p>All properties with the prefix <tt>general</tt> contain context for the entire experiment such as lab, institution, and experimentors. For session-delimited data from the same experiment, these fields will all be the same. Note that most of this information was pulled from the publishing paper and not from any of the downloadable data.</p>
<p>The only required property is the <tt>identifier</tt>, which distinguishes one session from another within an experiment. In our case, the ALM-3 data uses a combination of session date and animal ID.</p>
<h2 id="7">The ALM-3 File Structure</h2>
<p>Each ALM-3 session has three files: a metadata .mat file describing the experiment, a data structures .mat file containing analyzed data, and a raw .tar archive containing multiple raw electrophysiology data separated by trials as .mat files. All files will be merged into a single NWB file.</p>
<h2 id="8">Metadata</h2>
<p>ALM-3 Metadata contains information about the reference times, experimental context, methodology, as well as details of the electrophysiology, optophysiology, and behavioral portions of the experiment. A vast majority of these details are placed in <tt>general</tt> prefixed properties in NWB.</p>
<pre class="codeinput">fprintf(<span class="string">'Processing Meta Data from `%s`\n'</span>, metadata_loc);
loaded = load(metadata_loc, <span class="string">'meta_data'</span>);
meta = loaded.meta_data;

<span class="comment">% Experiment-specific treatment for animals with the ReaChR gene modification</span>
isreachr = any(cell2mat(strfind(meta.animalGeneModification, <span class="string">'ReaChR'</span>)));

<span class="comment">% Sessions are separated by date of experiment.</span>
nwb.general_session_id = meta.dateOfExperiment;

<span class="comment">% ALM-3 data start time is equivalent to the reference time.</span>
nwb.session_start_time = datetime([meta.dateOfExperiment meta.timeOfExperiment],<span class="keyword">...</span>
    <span class="string">'InputFormat'</span>, <span class="string">'yyyyMMddHHmmss'</span>, <span class="string">'TimeZone'</span>, <span class="string">'America/New_York'</span>); <span class="comment">% Eastern Daylight Time</span>
nwb.timestamps_reference_time = nwb.session_start_time;

nwb.general_experimenter = strjoin(meta.experimenters, <span class="string">', '</span>);
</pre>
<pre class="codeoutput">Processing Meta Data from `data/metadata/meta_data_ANM255201_20141124.mat`
</pre>
<pre class="codeinput">nwb.general_subject = types.core.Subject(<span class="keyword">...</span>
    <span class="string">'species'</span>, meta.species{1}, <span class="keyword">...</span>
    <span class="string">'subject_id'</span>, meta.animalID{1}(1,:), <span class="keyword">...</span><span class="comment"> %weird case with duplicate Animal ID</span>
    <span class="string">'sex'</span>, meta.sex, <span class="keyword">...</span>
    <span class="string">'age'</span>, meta.dateOfBirth, <span class="keyword">...</span>
    <span class="string">'description'</span>, [<span class="keyword">...</span>
        <span class="string">'Whisker Config: '</span> strjoin(meta.whiskerConfig, <span class="string">', '</span>) newline<span class="keyword">...</span>
        <span class="string">'Animal Source: '</span> strjoin(meta.animalSource, <span class="string">', '</span>)]);
</pre>
<p>Ideally, if a raw data field does not correspond directly to a NWB field, one would create their own using a <a href="https://pynwb.readthedocs.io/en/latest/extensions.html">custom NWB extension class</a>. However, since these fields are mostly experimental annotations, we instead pack the extra values into the <tt>description</tt> field as a string.</p>
<pre class="codeinput">
<span class="comment">% The formatStruct function simply prints the field and values given the struct.</span>
<span class="comment">% An optional cell array of field names specifies whitelist of fields to print.</span>
<span class="comment">% This function is provided with this script in the tutorials directory.</span>
nwb.general_subject.genotype = formatStruct(<span class="keyword">...</span>
    meta, <span class="keyword">...</span>
    {<span class="string">'animalStrain'</span>; <span class="string">'animalGeneModification'</span>; <span class="string">'animalGeneCopy'</span>;<span class="keyword">...</span>
    <span class="string">'animalGeneticBackground'</span>});

weight = {};
<span class="keyword">if</span> ~isempty(meta.weightBefore)
    weight{end+1} = <span class="string">'weightBefore'</span>;
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(meta.weightAfter)
    weight{end+1} = <span class="string">'weightAfter'</span>;
<span class="keyword">end</span>
weight = weight(~cellfun(<span class="string">'isempty'</span>, weight));
<span class="keyword">if</span> ~isempty(weight)
    nwb.general_subject.weight = formatStruct(meta, weight);
<span class="keyword">end</span>

<span class="comment">% general/experiment_description</span>
nwb.general_experiment_description = [<span class="keyword">...</span>
    formatStruct(meta, {<span class="string">'experimentType'</span>; <span class="string">'referenceAtlas'</span>}), <span class="keyword">...</span>
    newline, <span class="keyword">...</span>
    formatStruct(meta.behavior, {<span class="string">'task_keyword'</span>})];

<span class="comment">% Miscellaneous collection information from ALM-3 that didn't quite fit any NWB</span>
<span class="comment">% properties are stored in general/data_collection.</span>
nwb.general_data_collection = formatStruct(meta.extracellular,<span class="keyword">...</span>
    {<span class="string">'extracellularDataType'</span>;<span class="string">'cellType'</span>;<span class="string">'identificationMethod'</span>;<span class="string">'amplifierRolloff'</span>;<span class="keyword">...</span>
    <span class="string">'spikeSorting'</span>;<span class="string">'ADunit'</span>});

<span class="comment">% Device objects are essentially just a list of device names.  We store the probe</span>
<span class="comment">% and laser hardware names here.</span>
probetype = meta.extracellular.probeType{1};
probeSource = meta.extracellular.probeSource{1};
deviceName = [probetype <span class="string">' ('</span> probeSource <span class="string">')'</span>];
nwb.general_devices.set(deviceName, types.core.Device());

<span class="keyword">if</span> isreachr
    laserName = <span class="string">'laser-594nm (Cobolt Inc., Cobolt Mambo 100)'</span>;
<span class="keyword">else</span>
    laserName = <span class="string">'laser-473nm (Laser Quantum, Gem 473)'</span>;
<span class="keyword">end</span>
nwb.general_devices.set(laserName, types.core.Device());
</pre>
<pre class="codeinput">structDesc = {<span class="string">'recordingCoordinates'</span>;<span class="string">'recordingMarker'</span>;<span class="string">'recordingType'</span>;<span class="string">'penetrationN'</span>;<span class="keyword">...</span>
    <span class="string">'groundCoordinates'</span>};
<span class="keyword">if</span> ~isempty(meta.extracellular.referenceCoordinates)
    structDesc{end+1} = <span class="string">'referenceCoordinates'</span>;
<span class="keyword">end</span>
recordingLocation = meta.extracellular.recordingLocation{1};
egroup = types.core.ElectrodeGroup(<span class="keyword">...</span>
    <span class="string">'description'</span>, formatStruct(meta.extracellular, structDesc),<span class="keyword">...</span>
    <span class="string">'location'</span>, recordingLocation,<span class="keyword">...</span>
    <span class="string">'device'</span>, types.untyped.SoftLink([<span class="string">'/general/devices/'</span> deviceName]));
nwb.general_extracellular_ephys.set(deviceName, egroup);
</pre>
<p>The NWB <b>ElectrodeGroup</b> object stores experimental information regarding a group of probes. Doing so requires a <b>SoftLink</b> to the probe specified under <tt>general_devices</tt>. SoftLink objects are direct maps to <a href="https://portal.hdfgroup.org/display/HDF5/H5L_CREATE_SOFT">HDF5 Soft Links</a> on export, and thus, require a true HDF5 path.</p>
<pre class="codeinput">
<span class="comment">% You can specify column names and values as key-value arguments in the DynamicTable</span>
<span class="comment">% constructor.</span>
dtColNames = {<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>, <span class="string">'imp'</span>, <span class="string">'location'</span>, <span class="string">'filtering'</span>,<span class="string">'group'</span>, <span class="string">'group_name'</span>};
dynTable = types.hdmf_common.DynamicTable(<span class="keyword">...</span>
    <span class="string">'colnames'</span>, dtColNames,<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'Electrodes'</span>,<span class="keyword">...</span>
    <span class="string">'x'</span>, types.hdmf_common.VectorData(<span class="string">'description'</span>, <span class="string">'x coordinate of the channel location in the brain (+x is posterior).'</span>),<span class="keyword">...</span>
    <span class="string">'y'</span>, types.hdmf_common.VectorData(<span class="string">'description'</span>, <span class="string">'y coordinate of the channel location in the brain (+y is inferior).'</span>),<span class="keyword">...</span>
    <span class="string">'z'</span>, types.hdmf_common.VectorData(<span class="string">'description'</span>, <span class="string">'z coordinate of the channel location in the brain (+z is right).'</span>),<span class="keyword">...</span>
    <span class="string">'imp'</span>, types.hdmf_common.VectorData(<span class="string">'description'</span>, <span class="string">'Impedance of the channel.'</span>),<span class="keyword">...</span>
    <span class="string">'location'</span>, types.hdmf_common.VectorData(<span class="string">'description'</span>, [<span class="string">'Location of the electrode (channel). '</span><span class="keyword">...</span>
    <span class="string">'Specify the area, layer, comments on estimation of area/layer, stereotaxic coordinates if '</span><span class="keyword">...</span>
    <span class="string">'in vivo, etc. Use standard atlas names for anatomical regions when possible.'</span>]),<span class="keyword">...</span>
    <span class="string">'filtering'</span>, types.hdmf_common.VectorData(<span class="string">'description'</span>, <span class="string">'Description of hardware filtering.'</span>),<span class="keyword">...</span>
    <span class="string">'group'</span>, types.hdmf_common.VectorData(<span class="string">'description'</span>, <span class="string">'Reference to the ElectrodeGroup this electrode is a part of.'</span>),<span class="keyword">...</span>
    <span class="string">'group_name'</span>, types.hdmf_common.VectorData(<span class="string">'description'</span>, <span class="string">'Name of the ElectrodeGroup this electrode is a part of.'</span>));

<span class="comment">% Raw HDF5 path to the above electrode group. Referenced by</span>
<span class="comment">% the general/extracellular_ephys Dynamic Table</span>
egroupPath = [<span class="string">'/general/extracellular_ephys/'</span> deviceName];
eGroupReference = types.untyped.ObjectView(egroupPath);
<span class="keyword">for</span> i = 1:length(meta.extracellular.siteLocations)
    location = meta.extracellular.siteLocations{i};
    <span class="comment">% Add each row in the dynamic table. The `id` column is populated</span>
    <span class="comment">% dynamically.</span>
    dynTable.addRow(<span class="keyword">...</span>
        <span class="string">'x'</span>, location(1), <span class="string">'y'</span>, location(2), <span class="string">'z'</span>, location(3),<span class="keyword">...</span>
        <span class="string">'imp'</span>, 0,<span class="keyword">...</span>
        <span class="string">'location'</span>, recordingLocation,<span class="keyword">...</span>
        <span class="string">'filtering'</span>, <span class="string">''</span>,<span class="keyword">...</span>
        <span class="string">'group'</span>, eGroupReference,<span class="keyword">...</span>
        <span class="string">'group_name'</span>, probetype);
<span class="keyword">end</span>
</pre>
<p>The <tt>group</tt> column in the Dynamic Table contains an <b>ObjectView</b> to the previously created <tt>ElectrodeGroup</tt>. An <tt>ObjectView</tt> can be best thought of as a direct pointer to another typed object. It also directly maps to a <a href="https://portal.hdfgroup.org/display/HDF5/H5R_CREATE">HDF5 Object Reference</a>, thus the HDF5 path requirement.  <tt>ObjectViews</tt> are slightly different from <tt>SoftLinks</tt> in that they can be stored in datasets (data columns, tables, and <tt>data</tt> fields in <tt>NWBData</tt> objects).</p>
<pre class="codeinput">nwb.general_extracellular_ephys_electrodes = dynTable;
</pre>
<p>The <tt>electrodes</tt> property in <tt>extracellular_ephys</tt> is a special keyword in NWB that must be paired with a <b>Dynamic Table</b>. These are tables which can have an unbounded number of columns and rows, each as their own dataset. With the exception of the <tt>id</tt> column, all other columns must be <b>VectorData</b> or <b>VectorIndex</b> objects. The <tt>id</tt> column, meanwhile, must be an <b>ElementIdentifiers</b> object. The names of all used columns are specified in the in the <tt>colnames</tt> property as a cell array of strings.</p>
<pre class="codeinput">
<span class="comment">% general/optogenetics/photostim</span>
nwb.general_optogenetics.set(<span class="string">'photostim'</span>, <span class="keyword">...</span>
    types.core.OptogeneticStimulusSite(<span class="keyword">...</span>
    <span class="string">'excitation_lambda'</span>, meta.photostim.photostimWavelength{1}, <span class="keyword">...</span>
    <span class="string">'location'</span>, meta.photostim.photostimLocation{1}, <span class="keyword">...</span>
    <span class="string">'device'</span>, types.untyped.SoftLink([<span class="string">'/general/devices/'</span> laserName]), <span class="keyword">...</span>
    <span class="string">'description'</span>, formatStruct(meta.photostim, {<span class="keyword">...</span>
    <span class="string">'stimulationMethod'</span>;<span class="string">'photostimCoordinates'</span>;<span class="string">'identificationMethod'</span>})));
</pre>
<h2 id="15">Analysis Data Structure</h2>
<p>The ALM-3 data structures .mat file contains analyzed spike data, trial-specific parameters, and behavioral analysis data.</p>
<h2 id="16">Hashes</h2>
<p>ALM-3 stores its data structures in the form of <b>hashes</b> which are essentially the same as python's dictionaries or MATLAB's maps but where the keys and values are stored under separate struct fields. Getting a hashed value from a key involves retrieving the array index that the key is in and applying it to the parallel array in the values field.</p>
<p>You can find more information about hashes and how they're used on the <a href="https://crcns.org/data-sets/motor-cortex/alm-3/about-alm-3">ALM-3 about page</a>.</p>
<pre class="codeinput">fprintf(<span class="string">'Processing Data Structure `%s`\n'</span>, datastructure_loc);
loaded = load(datastructure_loc, <span class="string">'obj'</span>);
data = loaded.obj;

<span class="comment">% wherein each cell is one trial. We must populate this way because trials</span>
<span class="comment">% may not be in trial order.</span>
<span class="comment">% Trial timeseries will be a compound type under intervals/trials.</span>
trial_timeseries = cell(size(data.trialIds));
</pre>
<pre class="codeoutput">Processing Data Structure `data/data_structure_files/data_structure_ANM255201_20141124.mat`
</pre>
<p>NWB comes with default support for trial-based data. These must be <b>TimeIntervals</b> that are placed in the <tt>intervals</tt> property. Note that <tt>trials</tt> is a special keyword that is required for PyNWB compatibility.</p>
<pre class="codeinput">ephus = data.timeSeriesArrayHash.value{1};
ephusUnit = data.timeUnitNames{data.timeUnitIds(ephus.timeUnit)};

<span class="comment">% Lick direction and timestamps trace</span>
tsIdx = strcmp(ephus.idStr, <span class="string">'lick_trace'</span>);
bts = types.core.BehavioralTimeSeries();

bts.timeseries.set(<span class="string">'lick_trace_ts'</span>, <span class="keyword">...</span>
    types.core.TimeSeries(<span class="keyword">...</span>
    <span class="string">'data'</span>, ephus.valueMatrix(:,tsIdx),<span class="keyword">...</span>
    <span class="string">'data_unit'</span>, ephusUnit,<span class="keyword">...</span>
    <span class="string">'description'</span>, ephus.idStrDetailed{tsIdx}, <span class="keyword">...</span>
    <span class="string">'timestamps'</span>, ephus.time, <span class="keyword">...</span>
    <span class="string">'timestamps_unit'</span>, ephusUnit));
nwb.acquisition.set(<span class="string">'lick_trace'</span>, bts);
bts_ref = types.untyped.ObjectView(<span class="string">'/acquisition/lick_trace/lick_trace_ts'</span>);

<span class="comment">% Acousto-optic modulator input trace</span>
tsIdx = strcmp(ephus.idStr, <span class="string">'aom_input_trace'</span>);
ts = types.core.TimeSeries(<span class="keyword">...</span>
    <span class="string">'data'</span>, ephus.valueMatrix(:,tsIdx), <span class="keyword">...</span>
    <span class="string">'data_unit'</span>, <span class="string">'Volts'</span>, <span class="keyword">...</span>
    <span class="string">'description'</span>, ephus.idStrDetailed{tsIdx}, <span class="keyword">...</span>
    <span class="string">'timestamps'</span>, ephus.time, <span class="keyword">...</span>
    <span class="string">'timestamps_unit'</span>, ephusUnit);
nwb.stimulus_presentation.set(<span class="string">'aom_input_trace'</span>, ts);
ts_ref = types.untyped.ObjectView(<span class="string">'/stimulus/presentation/aom_input_trace'</span>);

<span class="comment">% Laser power</span>
tsIdx = strcmp(ephus.idStr, <span class="string">'laser_power'</span>);
ots = types.core.OptogeneticSeries(<span class="keyword">...</span>
    <span class="string">'data'</span>, ephus.valueMatrix(:, tsIdx), <span class="keyword">...</span>
    <span class="string">'data_conversion'</span>, 1e-3, <span class="keyword">...</span><span class="comment"> % data is stored in mW, data unit for OptogeneticSeries is watts</span>
    <span class="string">'description'</span>, ephus.idStrDetailed{tsIdx}, <span class="keyword">...</span>
    <span class="string">'timestamps'</span>, ephus.time, <span class="keyword">...</span>
    <span class="string">'timestamps_unit'</span>, ephusUnit, <span class="keyword">...</span>
    <span class="string">'site'</span>, types.untyped.SoftLink(<span class="string">'/general/optogenetics/photostim'</span>));
nwb.stimulus_presentation.set(<span class="string">'laser_power'</span>, ots);
ots_ref = types.untyped.ObjectView(<span class="string">'/stimulus/presentation/laser_power'</span>);

<span class="comment">% Append trials timeseries references in order</span>
[ephus_trials, ~, trials_to_data] = unique(ephus.trial);
<span class="keyword">for</span> i=1:length(ephus_trials)
    i_loc = i == trials_to_data;
    t_start = find(i_loc, 1);
    t_count = sum(i_loc);
    trial = ephus_trials(i);

    trial_timeseries{trial}(end+(1:3), :) = {<span class="keyword">...</span>
        bts_ref int64(t_start) int64(t_count);<span class="keyword">...</span>
        ts_ref  int64(t_start) int64(t_count);<span class="keyword">...</span>
        ots_ref int64(t_start) int64(t_count)};
<span class="keyword">end</span>
</pre>
<p>The <tt>timeseries</tt> property of the <tt>TimeIntervals</tt> object is an example of a <b>compound data type</b>. These types are essentially tables of data in HDF5 and can be represented by a MATLAB table, an array of structs, or a struct of arrays. Beware: validation of column lengths here is not guaranteed by the type checker until export.</p>
<p>
<b>VectorIndex</b> objects index into a larger <b>VectorData</b> column. The object that is being referenced is indicated by the <tt>target</tt> property, which uses an ObjectView. Each element in the VectorIndex marks the <b>last</b> element in the corresponding vector data object for the VectorIndex row. Thus, the starting index for this row would be the previous index + 1. Note that these indices must be 0-indexed for compatibility with pynwb. You can see this in effect with the <tt>timeseries</tt> property which is indexed by the <tt>timeseries_index</tt> property.</p>
<p>Though TimeIntervals is a subclass of the DynamicTable type, we opt for populating the Dynamic Table data by column instead of using `addRow` here because of how the data is formatted. DynamicTable is flexible enough to accomodate both styles of data conversion.</p>
<pre class="codeinput">trials_epoch = types.core.TimeIntervals(<span class="keyword">...</span>
    <span class="string">'colnames'</span>, {<span class="string">'start_time'</span>}, <span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'trial data and properties'</span>, <span class="keyword">...</span>
    <span class="string">'start_time'</span>, types.hdmf_common.VectorData(<span class="keyword">...</span>
        <span class="string">'data'</span>, data.trialStartTimes', <span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'Start time of epoch, in seconds.'</span>), <span class="keyword">...</span>
    <span class="string">'id'</span>, types.hdmf_common.ElementIdentifiers(<span class="keyword">...</span>
        <span class="string">'data'</span>, data.trialIds' ) );

<span class="comment">% Add columns for the trial types</span>
<span class="keyword">for</span> i=1:length(data.trialTypeStr)
    columnName = data.trialTypeStr{i};
    columnData = types.hdmf_common.VectorData(<span class="keyword">...</span>
         <span class="string">'data'</span>, data.trialTypeMat(i,:)', <span class="keyword">...</span><span class="comment"> % transpose for column vector</span>
         <span class="string">'description'</span>, data.trialTypeStr{i});
    trials_epoch.addColumn( columnName, columnData )
<span class="keyword">end</span>

<span class="comment">% Add columns for the trial properties</span>
<span class="keyword">for</span> i=1:length(data.trialPropertiesHash.keyNames)
    columnName = data.trialPropertiesHash.keyNames{i};
    descr = data.trialPropertiesHash.descr{i};
    <span class="keyword">if</span> iscellstr(descr)
        descr = strjoin(descr, newline);
    <span class="keyword">end</span>
    columnData = types.hdmf_common.VectorData(<span class="keyword">...</span>
         <span class="string">'data'</span>, data.trialPropertiesHash.value{i},<span class="keyword">...</span>
         <span class="string">'description'</span>, data.trialTypeStr{i});
    trials_epoch.addColumn( columnName, columnData )
<span class="keyword">end</span>

nwb.intervals_trials = trials_epoch;
</pre>
<p>Ephus spike data is separated into units which directly maps to the NWB property of the same name. Each such unit contains a group of analysed waveforms and spike times, all linked to a different subset of trials IDs.</p>
<p>The waveforms are placed in the <tt>analysis</tt> Set and are paired with their unit name ('unitx' where 'x' is some unit ID).</p>
<p>Trial IDs, wherever they are used, are placed in a relevent <tt>control</tt> property in the data object and will indicate what data is associated with what trial as defined in <tt>trials</tt>'s <tt>id</tt> column.</p>
<pre class="codeinput">nwb.units = types.core.Units(<span class="string">'colnames'</span>,<span class="keyword">...</span>
    {<span class="string">'spike_times'</span>, <span class="string">'trials'</span>, <span class="string">'waveforms'</span>},<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'Analysed Spike Events'</span>);
esHash = data.eventSeriesHash;
ids = regexp(esHash.keyNames, <span class="string">'^unit(\d+)$'</span>, <span class="string">'once'</span>, <span class="string">'tokens'</span>);
ids = str2double([ids{:}]);
nwb.units.spike_times = types.hdmf_common.VectorData(<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'timestamps of spikes'</span>);

<span class="keyword">for</span> i=1:length(ids)
    esData = esHash.value{i};
    <span class="comment">% Add trials ID reference</span>

    good_trials_mask = ismember(esData.eventTrials, nwb.intervals_trials.id.data);
    eventTrials = esData.eventTrials(good_trials_mask);
    eventTimes = esData.eventTimes(good_trials_mask);
    waveforms = esData.waveforms(good_trials_mask,:);
    channel = esData.channel(good_trials_mask);

    <span class="comment">% Add waveform data to "unitx" and associate with "waveform" column as ObjectView.</span>
    ses = types.core.SpikeEventSeries(<span class="keyword">...</span>
        <span class="string">'control'</span>, ids(i),<span class="keyword">...</span>
        <span class="string">'control_description'</span>, <span class="string">'Units Table ID'</span>,<span class="keyword">...</span>
        <span class="string">'data'</span>, waveforms .', <span class="keyword">...</span>
        <span class="string">'description'</span>, esHash.descr{i}, <span class="keyword">...</span>
        <span class="string">'timestamps'</span>, eventTimes, <span class="keyword">...</span>
        <span class="string">'timestamps_unit'</span>, data.timeUnitNames{data.timeUnitIds(esData.timeUnit)},<span class="keyword">...</span>
        <span class="string">'electrodes'</span>, types.hdmf_common.DynamicTableRegion(<span class="keyword">...</span>
            <span class="string">'description'</span>, <span class="string">'Electrodes involved with these spike events'</span>,<span class="keyword">...</span>
            <span class="string">'table'</span>, types.untyped.ObjectView(<span class="string">'/general/extracellular_ephys/electrodes'</span>),<span class="keyword">...</span>
            <span class="string">'data'</span>, channel - 1));
    ses_name = esHash.keyNames{i};
    ses_ref = types.untyped.ObjectView([<span class="string">'/analysis/'</span>, ses_name]);
    <span class="keyword">if</span> ~isempty(esData.cellType)
        ses.comments = [<span class="string">'cellType: '</span> esData.cellType{1}];
    <span class="keyword">end</span>
    nwb.analysis.set(ses_name, ses);
    nwb.units.addRow(<span class="keyword">...</span>
        <span class="string">'id'</span>, ids(i), <span class="string">'trials'</span>, eventTrials, <span class="string">'spike_times'</span>, eventTimes, <span class="string">'waveforms'</span>, ses_ref);

    <span class="comment">% Add this timeseries into the trials table as well.</span>
    [s_trials, ~, trials_to_data] = unique(eventTrials);
    <span class="keyword">for</span> j=1:length(s_trials)
        trial = s_trials(j);
        j_loc = j == trials_to_data;
        t_start = find(j_loc, 1);
        t_count = sum(j_loc);

        trial_timeseries{trial}(end+1, :) = {ses_ref int64(t_start) int64(t_count)};
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
<p>To better understand how <tt>spike_times_index</tt> and <tt>spike_times</tt> map to each other, refer to <a href="https://matnwb.readthedocs.io/en/latest/pages/tutorials/ecephys.html#13">this diagram</a> from the Extracellular Electrophysiology Tutorial.</p>
<h2 id="26">Raw Acquisition Data</h2>
<p>Each ALM-3 session is associated with a large number of raw voltage data grouped by trial ID. To map this data to NWB, each trial is created as its own <b>ElectricalSeries</b> object under the name 'trial n' where 'n' is the trial ID. The trials are then linked to the <tt>trials</tt> dynamic table for easy referencing.</p>
<pre class="codeinput">fprintf(<span class="string">'Processing Raw Acquisition Data from `%s` (will take a while)\n'</span>, rawdata_loc);
untarLoc = strrep(rawdata_loc, <span class="string">'.tar'</span>, <span class="string">''</span>);
<span class="keyword">if</span> ~isfolder(untarLoc)
    untar(rawdata_loc, fileparts(rawdata_loc));
<span class="keyword">end</span>

rawfiles = dir(untarLoc);
rawfiles = fullfile(untarLoc, {rawfiles(~[rawfiles.isdir]).name});

nrows = length(nwb.general_extracellular_ephys_electrodes.id.data);
tablereg = types.hdmf_common.DynamicTableRegion(<span class="keyword">...</span>
    <span class="string">'description'</span>,<span class="string">'Relevent Electrodes for this Electrical Series'</span>,<span class="keyword">...</span>
    <span class="string">'table'</span>,types.untyped.ObjectView(<span class="string">'/general/extracellular_ephys/electrodes'</span>),<span class="keyword">...</span>
    <span class="string">'data'</span>,(1:nrows) - 1);
objrefs = cell(size(rawfiles));

endTimestamps = trials_epoch.start_time.data;
<span class="keyword">for</span> i=1:length(rawfiles)
    tnumstr = regexp(rawfiles{i}, <span class="string">'_trial_(\d+)\.mat$'</span>, <span class="string">'tokens'</span>, <span class="string">'once'</span>);
    tnumstr = tnumstr{1};
    rawdata = load(rawfiles{i}, <span class="string">'ch_MUA'</span>, <span class="string">'TimeStamps'</span>);
    tnum = str2double(tnumstr);

    <span class="keyword">if</span> tnum &gt; length(endTimestamps)
        <span class="keyword">continue</span>; <span class="comment">% sometimes there are extra trials without an associated start time.</span>
    <span class="keyword">end</span>

    es = types.core.ElectricalSeries(<span class="keyword">...</span>
        <span class="string">'data'</span>, rawdata.ch_MUA,<span class="keyword">...</span>
        <span class="string">'description'</span>, [<span class="string">'Raw Voltage Acquisition for trial '</span> tnumstr],<span class="keyword">...</span>
        <span class="string">'electrodes'</span>, tablereg,<span class="keyword">...</span>
        <span class="string">'timestamps'</span>, rawdata.TimeStamps);
    tname = [<span class="string">'trial '</span> tnumstr];
    nwb.acquisition.set(tname, es);

    endTimestamps(tnum) = endTimestamps(tnum) + rawdata.TimeStamps(end);
    objrefs{tnum} = types.untyped.ObjectView([<span class="string">'/acquisition/'</span> tname]);
<span class="keyword">end</span>

<span class="comment">% Link to the raw data by adding the acquisition column with ObjectViews</span>
<span class="comment">% to the data</span>
emptyrefs = cellfun(<span class="string">'isempty'</span>, objrefs);
objrefs(emptyrefs) = {types.untyped.ObjectView(<span class="string">''</span>)};

trials_epoch.addColumn(<span class="string">'acquisition'</span>, types.hdmf_common.VectorData(<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'soft link to acquisition data for this trial'</span>,<span class="keyword">...</span>
    <span class="string">'data'</span>, [objrefs{:}]'));

trials_epoch.stop_time = types.hdmf_common.VectorData(<span class="keyword">...</span>
     <span class="string">'data'</span>, endTimestamps',<span class="keyword">...</span>
     <span class="string">'description'</span>, <span class="string">'the end time of each trial'</span>);
trials_epoch.colnames{end+1} = <span class="string">'stop_time'</span>;
</pre>
<pre class="codeoutput">Processing Raw Acquisition Data from `data/RawVoltageTraces/ANM255201_20141124.tar` (will take a while)
</pre>
<h2 id="27">Add timeseries to trials_epoch</h2>
<p>First, we'll format and store <tt>trial_timeseries</tt> into <tt>intervals_trials</tt>. note that <tt>timeseries_index</tt> data is 0-indexed.</p>
<pre class="codeinput">ts_len = cellfun(<span class="string">'size'</span>, trial_timeseries, 1);
nwb.intervals_trials.timeseries_index = types.hdmf_common.VectorIndex(<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'Index into Timeseries VectorData'</span>, <span class="keyword">...</span>
    <span class="string">'data'</span>, cumsum(ts_len)', <span class="keyword">...</span>
    <span class="string">'target'</span>, types.untyped.ObjectView(<span class="string">'/intervals/trials/timeseries'</span>) );

<span class="comment">% Intervals/trials/timeseries is a compound type so we use cell2table to</span>
<span class="comment">% convert this 2-d cell array into a compatible table.</span>
is_len_nonzero = ts_len &gt; 0;
trial_timeseries_table = cell2table(vertcat(trial_timeseries{is_len_nonzero}),<span class="keyword">...</span>
    <span class="string">'VariableNames'</span>, {<span class="string">'timeseries'</span>, <span class="string">'idx_start'</span>, <span class="string">'count'</span>});
trial_timeseries_table = movevars(trial_timeseries_table, <span class="string">'timeseries'</span>, <span class="string">'After'</span>, <span class="string">'count'</span>);

interval_trials_timeseries = types.core.TimeSeriesReferenceVectorData(<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'Index into TimeSeries data'</span>, <span class="keyword">...</span>
    <span class="string">'data'</span>, trial_timeseries_table);
nwb.intervals_trials.timeseries = interval_trials_timeseries;
nwb.intervals_trials.colnames{end+1} = <span class="string">'timeseries'</span>;
</pre>
<h2 id="28">Export</h2>
<pre class="codeinput">nwbFilePath = fullfile(output_directory, [identifier <span class="string">'.nwb'</span>]);
<span class="keyword">if</span> isfile(nwbFilePath)
    delete(nwbFilePath);
<span class="keyword">end</span>
nwbExport(nwb, nwbFilePath);
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% NWB File Conversion Tutorial
% How to convert trial-based experimental data to the Neurodata Without Borders file format using MatNWB.
% This example uses the <https://crcns.org/data-sets/motor-cortex/alm-3 CRCNS ALM-3>
% data set.  Information on how to download the data can be found on the 
% <https://crcns.org/data-sets/motor-cortex/download CRCNS Download Page>.  One should
% first familiarize themselves with the file format, which can be found on the
% <https://crcns.org/data-sets/motor-cortex/alm-3/about-alm-3 ALM-3 About Page> under
% the Documentation files.
% 
%  author: Lawrence Niu
%  contact: lawrence@vidriotech.com
%  last updated: Sep 14, 2024

%% Script Configuration
% The following section describes configuration parameters specific to the 
% publishing script, and can be skipped when implementing your own conversion.
% The parameters can be changed to fit any of the available sessions.

animal = 'ANM255201';
session = '20141124';

identifier = [animal '_' session];

% Specify the local path for the downloaded data:
data_root_path = 'data';

metadata_loc = fullfile(data_root_path, 'metadata', ['meta_data_' identifier '.mat']);
datastructure_loc = fullfile(data_root_path, 'data_structure_files',...
    ['data_structure_' identifier '.mat']);
rawdata_loc = fullfile(data_root_path, 'RawVoltageTraces', [identifier '.tar']);
%%
% The animal and session specifier can be changed with the |animal| and |session|
% variable name respectively.  |metadata_loc|, |datastructure_loc|, and |rawdata_loc|
% should refer to the metadata .mat file, the data structure .mat file, 
% and the raw .tar file.

output_directory = 'out';

if ~isfolder(output_directory)
    mkdir(output_directory);
end

source_file = [mfilename() '.m'];
[~, source_script, ~] = fileparts(source_file);
%%
% The NWB file will be saved in the output directory indicated by |output_directory|

%% General Information
nwb = NwbFile();
nwb.identifier = identifier;
nwb.general_source_script = source_script;
nwb.general_source_script_file_name = source_file;
nwb.general_lab = 'Svoboda';
nwb.general_keywords = {'Network models', 'Premotor cortex', 'Short-term memory'};
nwb.general_institution = ['Janelia Research Campus,'...
    ' Howard Huges Medical Institute, Ashburn, Virginia 20147, USA'];
nwb.general_related_publications = ...
    ['Li N, Daie K, Svoboda K, Druckmann S (2016).',...
    ' Robust neuronal dynamics in premotor cortex during motor planning.',...
    ' Nature. 7600:459-64. doi: 10.1038/nature17643'];
nwb.general_stimulus = 'photostim';
nwb.general_protocol = 'IACUC';
nwb.general_surgery = ['Mice were prepared for photoinhibition and ',...
    'electrophysiology with a clear-skull cap and a headpost. ',...
    'The scalp and periosteum over the dorsal surface of the skull were removed. ',...
    'A layer of cyanoacrylate adhesive (Krazy glue, Elmer''s Products Inc.) ',...
    'was directly applied to the intact skull. A custom made headpost ',...
    'was placed on the skull with its anterior edge aligned with the suture lambda ',...
    '(approximately over cerebellum) and cemented in place ',...
    'with clear dental acrylic (Lang Dental Jet Repair Acrylic; 1223-clear). ',...
    'A thin layer of clear dental acrylic was applied over the cyanoacrylate adhesive ',...
    'covering the entire exposed skull, ',...
    'followed by a thin layer of clear nail polish (Electron Microscopy Sciences, 72180).'];
nwb.session_description = sprintf('Animal `%s` on Session `%s`', animal, session);
%%
% All properties with the prefix |general| contain context for the entire experiment
% such as lab, institution, and experimentors.  For session-delimited data from the
% same experiment, these fields will all be the same.  Note that most of this
% information was pulled from the publishing paper and not from any of the downloadable data.
%%
% The only required property is the |identifier|, which distinguishes one session from
% another within an experiment.  In our case, the ALM-3 data uses a combination of
% session date and animal ID.

%% The ALM-3 File Structure
% Each ALM-3 session has three files: a metadata .mat file describing the experiment, a
% data structures .mat file containing analyzed data, and a raw .tar archive
% containing multiple raw electrophysiology data separated by trials as .mat files.
% All files will be merged into a single NWB file.

%% Metadata
% ALM-3 Metadata contains information about the reference times, experimental context,
% methodology, as well as details of the electrophysiology, optophysiology, and behavioral
% portions of the experiment.  A vast majority of these details are placed in |general|
% prefixed properties in NWB.
fprintf('Processing Meta Data from `%s`\n', metadata_loc);
loaded = load(metadata_loc, 'meta_data');
meta = loaded.meta_data;

% Experiment-specific treatment for animals with the ReaChR gene modification
isreachr = any(cell2mat(strfind(meta.animalGeneModification, 'ReaChR')));

% Sessions are separated by date of experiment.
nwb.general_session_id = meta.dateOfExperiment;

% ALM-3 data start time is equivalent to the reference time.
nwb.session_start_time = datetime([meta.dateOfExperiment meta.timeOfExperiment],...
    'InputFormat', 'yyyyMMddHHmmss', 'TimeZone', 'America/New_York'); % Eastern Daylight Time
nwb.timestamps_reference_time = nwb.session_start_time;

nwb.general_experimenter = strjoin(meta.experimenters, ', ');

%%
nwb.general_subject = types.core.Subject(...
    'species', meta.species{1}, ...
    'subject_id', meta.animalID{1}(1,:), ... %weird case with duplicate Animal ID
    'sex', meta.sex, ...
    'age', meta.dateOfBirth, ...
    'description', [...
        'Whisker Config: ' strjoin(meta.whiskerConfig, ', ') newline...
        'Animal Source: ' strjoin(meta.animalSource, ', ')]);
%%
% Ideally, if a raw data field does not correspond directly to a NWB field, one would
% create their own using a
% <https://pynwb.readthedocs.io/en/latest/extensions.html custom NWB extension class>.
% However, since these fields are mostly experimental annotations, we instead pack the
% extra values into the |description| field as a string.

% The formatStruct function simply prints the field and values given the struct.
% An optional cell array of field names specifies whitelist of fields to print. 
% This function is provided with this script in the tutorials directory.
nwb.general_subject.genotype = formatStruct(...
    meta, ...
    {'animalStrain'; 'animalGeneModification'; 'animalGeneCopy';...
    'animalGeneticBackground'});

weight = {};
if ~isempty(meta.weightBefore)
    weight{end+1} = 'weightBefore';
end
if ~isempty(meta.weightAfter)
    weight{end+1} = 'weightAfter';
end
weight = weight(~cellfun('isempty', weight));
if ~isempty(weight)
    nwb.general_subject.weight = formatStruct(meta, weight);
end

% general/experiment_description
nwb.general_experiment_description = [...
    formatStruct(meta, {'experimentType'; 'referenceAtlas'}), ...
    newline, ...
    formatStruct(meta.behavior, {'task_keyword'})];

% Miscellaneous collection information from ALM-3 that didn't quite fit any NWB 
% properties are stored in general/data_collection.
nwb.general_data_collection = formatStruct(meta.extracellular,...
    {'extracellularDataType';'cellType';'identificationMethod';'amplifierRolloff';...
    'spikeSorting';'ADunit'});

% Device objects are essentially just a list of device names.  We store the probe
% and laser hardware names here.
probetype = meta.extracellular.probeType{1};
probeSource = meta.extracellular.probeSource{1};
deviceName = [probetype ' (' probeSource ')'];
nwb.general_devices.set(deviceName, types.core.Device());

if isreachr
    laserName = 'laser-594nm (Cobolt Inc., Cobolt Mambo 100)';
else
    laserName = 'laser-473nm (Laser Quantum, Gem 473)';
end
nwb.general_devices.set(laserName, types.core.Device());

%%
structDesc = {'recordingCoordinates';'recordingMarker';'recordingType';'penetrationN';...
    'groundCoordinates'};
if ~isempty(meta.extracellular.referenceCoordinates)
    structDesc{end+1} = 'referenceCoordinates';
end
recordingLocation = meta.extracellular.recordingLocation{1};
egroup = types.core.ElectrodeGroup(...
    'description', formatStruct(meta.extracellular, structDesc),...
    'location', recordingLocation,...
    'device', types.untyped.SoftLink(['/general/devices/' deviceName]));
nwb.general_extracellular_ephys.set(deviceName, egroup);
%%
% The NWB *ElectrodeGroup* object stores experimental information regarding a 
% group of probes.  Doing so requires a *SoftLink* to the probe specified under
% |general_devices|.  SoftLink objects are direct maps to
% <https://portal.hdfgroup.org/display/HDF5/H5L_CREATE_SOFT HDF5 Soft Links> on 
% export, and thus, require a true HDF5 path.

% You can specify column names and values as key-value arguments in the DynamicTable
% constructor.
dtColNames = {'x', 'y', 'z', 'imp', 'location', 'filtering','group', 'group_name'};
dynTable = types.hdmf_common.DynamicTable(...
    'colnames', dtColNames,...
    'description', 'Electrodes',...
    'x', types.hdmf_common.VectorData('description', 'x coordinate of the channel location in the brain (+x is posterior).'),...
    'y', types.hdmf_common.VectorData('description', 'y coordinate of the channel location in the brain (+y is inferior).'),...
    'z', types.hdmf_common.VectorData('description', 'z coordinate of the channel location in the brain (+z is right).'),...
    'imp', types.hdmf_common.VectorData('description', 'Impedance of the channel.'),...
    'location', types.hdmf_common.VectorData('description', ['Location of the electrode (channel). '...
    'Specify the area, layer, comments on estimation of area/layer, stereotaxic coordinates if '...
    'in vivo, etc. Use standard atlas names for anatomical regions when possible.']),...
    'filtering', types.hdmf_common.VectorData('description', 'Description of hardware filtering.'),...
    'group', types.hdmf_common.VectorData('description', 'Reference to the ElectrodeGroup this electrode is a part of.'),...
    'group_name', types.hdmf_common.VectorData('description', 'Name of the ElectrodeGroup this electrode is a part of.'));

% Raw HDF5 path to the above electrode group. Referenced by
% the general/extracellular_ephys Dynamic Table
egroupPath = ['/general/extracellular_ephys/' deviceName];
eGroupReference = types.untyped.ObjectView(egroupPath);
for i = 1:length(meta.extracellular.siteLocations)
    location = meta.extracellular.siteLocations{i};
    % Add each row in the dynamic table. The `id` column is populated
    % dynamically.
    dynTable.addRow(...
        'x', location(1), 'y', location(2), 'z', location(3),...
        'imp', 0,...
        'location', recordingLocation,...
        'filtering', '',...
        'group', eGroupReference,...
        'group_name', probetype);
end
%%
% The |group| column in the Dynamic Table contains an *ObjectView* to the previously
% created |ElectrodeGroup|.  An |ObjectView| can be best thought of as a direct
% pointer to another typed object.  It also directly maps to a 
% <https://portal.hdfgroup.org/display/HDF5/H5R_CREATE HDF5 Object Reference>,
% thus the HDF5 path requirement.  |ObjectViews| are slightly different from |SoftLinks|
% in that they can be stored in datasets (data columns, tables, and |data| fields in
% |NWBData| objects).

nwb.general_extracellular_ephys_electrodes = dynTable;
%%
% The |electrodes| property in |extracellular_ephys| is a special keyword in NWB that
% must be paired with a *Dynamic Table*.  These are tables which can have an unbounded
% number of columns and rows, each as their own dataset.  With the exception of the |id|
% column, all other columns must be *VectorData* or *VectorIndex* objects.  The |id|
% column, meanwhile, must be an *ElementIdentifiers* object.  The names of all used
% columns are specified in the in the |colnames| property as a cell array of strings.

% general/optogenetics/photostim
nwb.general_optogenetics.set('photostim', ...
    types.core.OptogeneticStimulusSite(...
    'excitation_lambda', meta.photostim.photostimWavelength{1}, ...
    'location', meta.photostim.photostimLocation{1}, ...
    'device', types.untyped.SoftLink(['/general/devices/' laserName]), ...
    'description', formatStruct(meta.photostim, {...
    'stimulationMethod';'photostimCoordinates';'identificationMethod'})));

%% Analysis Data Structure
% The ALM-3 data structures .mat file contains analyzed spike data, trial-specific
% parameters, and behavioral analysis data.
%% Hashes
% ALM-3 stores its data structures in the form of *hashes* which are essentially the
% same as python's dictionaries or MATLAB's maps but where the keys and values
% are stored under separate struct fields.  Getting a hashed value from a key
% involves retrieving the array index that the key is in and applying it to the
% parallel array in the values field.
%%
% You can find more information about hashes and how they're used on the
% <https://crcns.org/data-sets/motor-cortex/alm-3/about-alm-3 ALM-3 about page>.
fprintf('Processing Data Structure `%s`\n', datastructure_loc);
loaded = load(datastructure_loc, 'obj');
data = loaded.obj;

% wherein each cell is one trial. We must populate this way because trials
% may not be in trial order.
% Trial timeseries will be a compound type under intervals/trials.
trial_timeseries = cell(size(data.trialIds)); 

%%
% NWB comes with default support for trial-based data.  These must be *TimeIntervals* that
% are placed in the |intervals| property.  Note that |trials| is a special
% keyword that is required for PyNWB compatibility.

ephus = data.timeSeriesArrayHash.value{1};
ephusUnit = data.timeUnitNames{data.timeUnitIds(ephus.timeUnit)};

% Lick direction and timestamps trace
tsIdx = strcmp(ephus.idStr, 'lick_trace');
bts = types.core.BehavioralTimeSeries();

bts.timeseries.set('lick_trace_ts', ...
    types.core.TimeSeries(...
    'data', ephus.valueMatrix(:,tsIdx),...
    'data_unit', ephusUnit,...
    'description', ephus.idStrDetailed{tsIdx}, ...
    'timestamps', ephus.time, ...
    'timestamps_unit', ephusUnit));
nwb.acquisition.set('lick_trace', bts);
bts_ref = types.untyped.ObjectView('/acquisition/lick_trace/lick_trace_ts');

% Acousto-optic modulator input trace
tsIdx = strcmp(ephus.idStr, 'aom_input_trace');
ts = types.core.TimeSeries(...
    'data', ephus.valueMatrix(:,tsIdx), ...
    'data_unit', 'Volts', ...
    'description', ephus.idStrDetailed{tsIdx}, ...
    'timestamps', ephus.time, ...
    'timestamps_unit', ephusUnit);
nwb.stimulus_presentation.set('aom_input_trace', ts);
ts_ref = types.untyped.ObjectView('/stimulus/presentation/aom_input_trace');

% Laser power
tsIdx = strcmp(ephus.idStr, 'laser_power');
ots = types.core.OptogeneticSeries(...
    'data', ephus.valueMatrix(:, tsIdx), ...
    'data_conversion', 1e-3, ... % data is stored in mW, data unit for OptogeneticSeries is watts
    'description', ephus.idStrDetailed{tsIdx}, ...
    'timestamps', ephus.time, ...
    'timestamps_unit', ephusUnit, ...
    'site', types.untyped.SoftLink('/general/optogenetics/photostim'));
nwb.stimulus_presentation.set('laser_power', ots);
ots_ref = types.untyped.ObjectView('/stimulus/presentation/laser_power');

% Append trials timeseries references in order
[ephus_trials, ~, trials_to_data] = unique(ephus.trial);
for i=1:length(ephus_trials)
    i_loc = i == trials_to_data;
    t_start = find(i_loc, 1);
    t_count = sum(i_loc);
    trial = ephus_trials(i);
    
    trial_timeseries{trial}(end+(1:3), :) = {...
        bts_ref int64(t_start) int64(t_count);...
        ts_ref  int64(t_start) int64(t_count);...
        ots_ref int64(t_start) int64(t_count)};
end

%%
% The |timeseries| property of the |TimeIntervals| object is an example of a
% *compound data type*.  These types are essentially tables of data in HDF5 and can
% be represented by a MATLAB table, an array of structs, or a struct of arrays.
% Beware: validation of column lengths here is not guaranteed by the type checker
% until export.
%%
% *VectorIndex* objects index into a larger *VectorData* column.  The object that is
% being referenced is indicated by the |target| property, which uses an ObjectView.
% Each element in the VectorIndex marks the *last* element in the corresponding
% vector data object for the VectorIndex row.  Thus, the starting index for this
% row would be the previous index + 1.  Note that these indices must be 0-indexed
% for compatibility with pynwb.  You can see this in effect with the |timeseries|
% property which is indexed by the |timeseries_index| property.
%%
% Though TimeIntervals is a subclass of the DynamicTable type, we opt for
% populating the Dynamic Table data by column instead of using `addRow`
% here because of how the data is formatted. DynamicTable is flexible
% enough to accomodate both styles of data conversion.
trials_epoch = types.core.TimeIntervals(...
    'colnames', {'start_time'}, ...
    'description', 'trial data and properties', ...
    'start_time', types.hdmf_common.VectorData(...
        'data', data.trialStartTimes', ...
        'description', 'Start time of epoch, in seconds.'), ...
    'id', types.hdmf_common.ElementIdentifiers(...
        'data', data.trialIds' ) );

% Add columns for the trial types
for i=1:length(data.trialTypeStr)
    columnName = data.trialTypeStr{i};
    columnData = types.hdmf_common.VectorData(...
         'data', data.trialTypeMat(i,:)', ... % transpose for column vector 
         'description', data.trialTypeStr{i});
    trials_epoch.addColumn( columnName, columnData )
end

% Add columns for the trial properties
for i=1:length(data.trialPropertiesHash.keyNames)
    columnName = data.trialPropertiesHash.keyNames{i};
    descr = data.trialPropertiesHash.descr{i};
    if iscellstr(descr)
        descr = strjoin(descr, newline);
    end
    columnData = types.hdmf_common.VectorData(...
         'data', data.trialPropertiesHash.value{i},...
         'description', data.trialTypeStr{i});
    trials_epoch.addColumn( columnName, columnData )
end

nwb.intervals_trials = trials_epoch;

%%
% Ephus spike data is separated into units which directly maps to the NWB property
% of the same name.  Each such unit contains a group of analysed waveforms and spike
% times, all linked to a different subset of trials IDs.

%%
% The waveforms are placed in the |analysis| Set and are paired with their unit name
% ('unitx' where 'x' is some unit ID).

%%
% Trial IDs, wherever they are used, are placed in a relevent |control| property in the
% data object and will indicate what data is associated with what trial as
% defined in |trials|'s |id| column.

nwb.units = types.core.Units('colnames',...
    {'spike_times', 'trials', 'waveforms'},...
    'description', 'Analysed Spike Events');
esHash = data.eventSeriesHash;
ids = regexp(esHash.keyNames, '^unit(\d+)$', 'once', 'tokens');
ids = str2double([ids{:}]);
nwb.units.spike_times = types.hdmf_common.VectorData(...
    'description', 'timestamps of spikes');

for i=1:length(ids)
    esData = esHash.value{i};
    % Add trials ID reference
    
    good_trials_mask = ismember(esData.eventTrials, nwb.intervals_trials.id.data);
    eventTrials = esData.eventTrials(good_trials_mask);
    eventTimes = esData.eventTimes(good_trials_mask);
    waveforms = esData.waveforms(good_trials_mask,:);
    channel = esData.channel(good_trials_mask);
    
    % Add waveform data to "unitx" and associate with "waveform" column as ObjectView.
    ses = types.core.SpikeEventSeries(...
        'control', ids(i),...
        'control_description', 'Units Table ID',...
        'data', waveforms .', ...
        'description', esHash.descr{i}, ...
        'timestamps', eventTimes, ...
        'timestamps_unit', data.timeUnitNames{data.timeUnitIds(esData.timeUnit)},...
        'electrodes', types.hdmf_common.DynamicTableRegion(...
            'description', 'Electrodes involved with these spike events',...
            'table', types.untyped.ObjectView('/general/extracellular_ephys/electrodes'),...
            'data', channel - 1));
    ses_name = esHash.keyNames{i};
    ses_ref = types.untyped.ObjectView(['/analysis/', ses_name]);
    if ~isempty(esData.cellType)
        ses.comments = ['cellType: ' esData.cellType{1}];
    end
    nwb.analysis.set(ses_name, ses);
    nwb.units.addRow(...
        'id', ids(i), 'trials', eventTrials, 'spike_times', eventTimes, 'waveforms', ses_ref);
    
    % Add this timeseries into the trials table as well.
    [s_trials, ~, trials_to_data] = unique(eventTrials);
    for j=1:length(s_trials)
        trial = s_trials(j);
        j_loc = j == trials_to_data;
        t_start = find(j_loc, 1);
        t_count = sum(j_loc);
        
        trial_timeseries{trial}(end+1, :) = {ses_ref int64(t_start) int64(t_count)};
    end
end
%%
% To better understand how |spike_times_index| and |spike_times| map to each other, refer to
% <https://matnwb.readthedocs.io/en/latest/pages/tutorials/ecephys.html#13 this
% diagram> from the Extracellular Electrophysiology Tutorial.

%% Raw Acquisition Data
% Each ALM-3 session is associated with a large number of raw voltage data grouped by
% trial ID. To map this data to NWB, each trial is created as its own *ElectricalSeries*
% object under the name 'trial n' where 'n' is the trial ID.  The trials are then linked
% to the |trials| dynamic table for easy referencing.
fprintf('Processing Raw Acquisition Data from `%s` (will take a while)\n', rawdata_loc);
untarLoc = strrep(rawdata_loc, '.tar', '');
if ~isfolder(untarLoc)
    untar(rawdata_loc, fileparts(rawdata_loc));
end

rawfiles = dir(untarLoc);
rawfiles = fullfile(untarLoc, {rawfiles(~[rawfiles.isdir]).name});

nrows = length(nwb.general_extracellular_ephys_electrodes.id.data);
tablereg = types.hdmf_common.DynamicTableRegion(...
    'description','Relevent Electrodes for this Electrical Series',...
    'table',types.untyped.ObjectView('/general/extracellular_ephys/electrodes'),...
    'data',(1:nrows) - 1);
objrefs = cell(size(rawfiles));

endTimestamps = trials_epoch.start_time.data;
for i=1:length(rawfiles)
    tnumstr = regexp(rawfiles{i}, '_trial_(\d+)\.mat$', 'tokens', 'once');
    tnumstr = tnumstr{1};
    rawdata = load(rawfiles{i}, 'ch_MUA', 'TimeStamps');
    tnum = str2double(tnumstr);
    
    if tnum > length(endTimestamps)
        continue; % sometimes there are extra trials without an associated start time.
    end
    
    es = types.core.ElectricalSeries(...
        'data', rawdata.ch_MUA,...
        'description', ['Raw Voltage Acquisition for trial ' tnumstr],...
        'electrodes', tablereg,...
        'timestamps', rawdata.TimeStamps);
    tname = ['trial ' tnumstr];
    nwb.acquisition.set(tname, es);
    
    endTimestamps(tnum) = endTimestamps(tnum) + rawdata.TimeStamps(end);
    objrefs{tnum} = types.untyped.ObjectView(['/acquisition/' tname]);
end

% Link to the raw data by adding the acquisition column with ObjectViews
% to the data
emptyrefs = cellfun('isempty', objrefs);
objrefs(emptyrefs) = {types.untyped.ObjectView('')};

trials_epoch.addColumn('acquisition', types.hdmf_common.VectorData(...
    'description', 'soft link to acquisition data for this trial',...
    'data', [objrefs{:}]'));

trials_epoch.stop_time = types.hdmf_common.VectorData(...
     'data', endTimestamps',...
     'description', 'the end time of each trial');
trials_epoch.colnames{end+1} = 'stop_time';

%% Add timeseries to trials_epoch
% First, we'll format and store |trial_timeseries| into |intervals_trials|.
% note that |timeseries_index| data is 0-indexed.
ts_len = cellfun('size', trial_timeseries, 1);
nwb.intervals_trials.timeseries_index = types.hdmf_common.VectorIndex(...
    'description', 'Index into Timeseries VectorData', ...
    'data', cumsum(ts_len)', ...
    'target', types.untyped.ObjectView('/intervals/trials/timeseries') );

% Intervals/trials/timeseries is a compound type so we use cell2table to
% convert this 2-d cell array into a compatible table.
is_len_nonzero = ts_len > 0;
trial_timeseries_table = cell2table(vertcat(trial_timeseries{is_len_nonzero}),...
    'VariableNames', {'timeseries', 'idx_start', 'count'});
trial_timeseries_table = movevars(trial_timeseries_table, 'timeseries', 'After', 'count');

interval_trials_timeseries = types.core.TimeSeriesReferenceVectorData(...
    'description', 'Index into TimeSeries data', ...
    'data', trial_timeseries_table);
nwb.intervals_trials.timeseries = interval_trials_timeseries;
nwb.intervals_trials.colnames{end+1} = 'timeseries';

%% Export
nwbFilePath = fullfile(output_directory, [identifier '.nwb']);
if isfile(nwbFilePath)
    delete(nwbFilePath);
end
nwbExport(nwb, nwbFilePath);

##### SOURCE END #####
-->
</body>
</html>
