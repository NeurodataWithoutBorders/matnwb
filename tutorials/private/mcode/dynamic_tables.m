%% DynamicTables Tutorial
% This is a user guide to interacting with <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> objects in MatNWB.
%% *MatNWB Setup*
% Start by setting up your MATLAB workspace. The code below adds the directory 
% containing the MatNWB package to the MATLAB search path. MatNWB works by automatically 
% creating API classes based on a defined schema.

%{
path_to_matnwb = '~/Repositories/matnwb'; % change to your own path location
addpath(genpath(pwd));
%}
%% Constructing a table with initialized columns
% The <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> class represents a column-based table to which you can add custom 
% columns. It consists of a description, a list of columns , and a list of row 
% IDs. You can create a <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> by first defining the <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/VectorData.html 
% *VectorData*> objects that will make up the columns of the table. Each <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/VectorData.html 
% *VectorData*> object must contain the same number of rows. A list of rows IDs 
% may be passed to the <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> using the id argument. Row IDs are a useful way to access row 
% information independent of row location index. The list of row IDs must be cast 
% as an <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/ElementIdentifiers.html 
% *ElementIdentifiers*> object before being passed to the <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> object. If no value is passed to id, an <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/ElementIdentifiers.html 
% *ElementIdentifiers*> object with 0-indexed row IDs will be created for you 
% automatically.
% 
% *MATLAB Syntax Note*:  Using column vectors is crucial to properly build vectors 
% and tables. When defining individual values, make sure to use semi-colon (;) 
% instead of instead of comma (,) when defining the data fields of these.

col1 = types.hdmf_common.VectorData( ...
    'description', 'column #1', ...
    'data', [1;2] ...
);

col2 = types.hdmf_common.VectorData( ...
    'description', 'column #2', ...
    'data', {'a';'b'} ...
);

my_table = types.hdmf_common.DynamicTable( ...
    'description', 'an example table', ...
    'colnames', {'col1', 'col2'}, ...
    'col1', col1, ...
    'col2', col2, ...
    'id', types.hdmf_common.ElementIdentifiers('data', [0;1]) ...  % 0-indexed, for compatibility with Python
);
my_table
%% Adding rows
% You can add rows to an existing <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> using the object's |addRow| method. One way of using this method 
% is to pass in the names of columns as parameter names followed by the elements 
% to append. The class of the elements of the column must match the elements to 
% append.

my_table.addRow('col1', 3, 'col2', {'c'}, 'id', 2);
%% Adding columns
% You can add new columns to an existing <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> object using the |addColumn| method. One way of using this method 
% is to pass in the names of each new column followed by the corresponding values 
% for each new column. The height of the new columns must match the height of 
% the table.

col3 = types.hdmf_common.VectorData('description', 'column #3', ...
    'data', [100; 200; 300]);
col4 = types.hdmf_common.VectorData('description', 'column #4', ...
    'data', {'a1'; 'b2'; 'c3'});

my_table.addColumn('col3', col3,'col4', col4);
%% Create MATLAB table and convert to dynamic table
% As an alternative to building a dynamic table using the <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> and <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/VectorData.html 
% *VectorData*> data types, it is also possible to create a MATLAB table and convert 
% it to a dynamic table. Lets create the same table as before, but using MATLAB's 
% table class:

% Create a table with two variables (columns):
T = table([1;2], {'a';'b'}, 'VariableNames', {'col1', 'col2'});
T.Properties.VariableDescriptions = {'column #1', 'column #2'};
% Adding rows

T(end+1, :) = {3, 'c'};
% Adding variables (columns)

T = addvars(T, [100;200;300], 'NewVariableNames',{'col3'});
T.Properties.VariableDescriptions{3} = 'column #3';

% Alternatively, a new variable can be added directly using dot syntax.
T.col4 = {'a1'; 'b2'; 'c3'};
T.Properties.VariableDescriptions{4} = 'column #4';
T
% Convert to dynamic table

dynamic_table = util.table2nwb(T, 'A MATLAB table that was converted to a dynamic table')
%% Enumerated (categorical) data
% <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_experimental/EnumData.html 
% |*EnumData*|> is a special type of column for storing an enumerated data type. 
% This way each unique value is stored once, and the data references those values 
% by index. Using this method is more efficient than storing a single value many 
% times, and has the advantage of communicating to downstream tools that the data 
% is categorical in nature.
% Warning Regarding EnumData
% <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_experimental/EnumData.html 
% |*EnumData*|> is currently an experimental feature and as such should not be 
% used in a production environment.

CellTypeElements = types.hdmf_common.VectorData(...
    'description', 'fixed set of elements referenced by cell_type' ...
    , 'data', {'aa', 'bb', 'cc'} ... % the enumerated elements
    );
CellType = types.hdmf_experimental.EnumData( ...
    'description', 'this column holds categorical variables' ... % properties derived from VectorData
    , 'data', [0, 1, 2, 1, 0] ... % zero-indexed offset to elements.
    , 'elements', types.untyped.ObjectView(CellTypeElements) ...
    );

MyTable = types.hdmf_common.DynamicTable('description', 'an example table');
MyTable.vectordata.set('cell_type_elements', CellTypeElements); % the *_elements format is required for compatibility with pynwb
MyTable.addColumn('cell_type', CellType);
%% Ragged array columns
% A table column with a different number of elements for each row is called 
% a "ragged array column." To define a table with a ragged array column, pass 
% both the <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/VectorData.html 
% *VectorData*> and the corresponding <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/VectorIndex.html 
% *VectorIndex*> as columns of the <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> object. The <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/VectorData.html 
% *VectorData*> columns will contain the data values. The <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/VectorIndex.html 
% *VectorIndex*> column serves to indicate how to arrange the data across rows. 
% By convention the <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/VectorIndex.html 
% *VectorIndex*> object corresponding to a particular column must have have the 
% same name with the addition of the '_index' suffix.
% 
% Below, the <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/VectorIndex.html 
% *VectorIndex*> values indicate to place the 1st to 3rd (inclusive) elements 
% of the <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/VectorData.html 
% *VectorData*> into the first row and 4th element into the second row. The resulting 
% table will have the cell {'1a'; '1b'; '1c'} in the first row and the cell {'2a'} 
% in the second row.


col1 = types.hdmf_common.VectorData( ...
    'description', 'column #1', ...
    'data', {'1a'; '1b'; '1c'; '2a'} ...
);

col1_index = types.hdmf_common.VectorIndex( ...
    'description', 'column #1 index', ...
    'target',types.untyped.ObjectView(col1), ...  % object view of target column
    'data', [3; 4] ...
);

table_ragged_col = types.hdmf_common.DynamicTable( ...
    'description', 'an example table', ...
    'colnames', {'col1'}, ...
    'col1', col1, ...
    'col1_index', col1_index, ...
    'id', types.hdmf_common.ElementIdentifiers('data', [0; 1]) ...  % 0-indexed, for compatibility with Python
);
% Adding ragged array rows
% You can add a new row to the ragged array column. Under the hood, the addRow 
% method will add the appropriate value to the VectorIndex column to maintain 
% proper formatting.

table_ragged_col.addRow('col1', {'3a'; '3b'; '3c'}, 'id', 2);
%% Accessing row elements
% You can access data from entire rows of a <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> object by calling the |getRow| method for the corresponding 
% object. You can supply either an individual row number or a list of row numbers.

my_table.getRow(1)
%% 
% If you want to access values for just a subset of columns you can pass in 
% the 'columns' argument along with a cell array with the desired column names

my_table.getRow(1:3, 'columns', {'col1'})
%% 
% You can also access specific rows by their corresponding row ID's, if they 
% have been defined, by supplying a 'true' Boolean to the 'useId' parameter

my_table.getRow(1, 'useId', true)
%% 
% For a ragged array columns, the |getRow| method will return a cell with different 
% number of elements for each row

table_ragged_col.getRow(1:2)
%% Accessing column elements
% To access all rows from a particular column use the .get method on the vectordata 
% field of the <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> object


my_table.vectordata.get('col2').data
%% Referencing rows of other tables
% You can create a column that references rows of other tables by adding a <file:///Users/cesar/Repositories/matnwb/doc/+types/+hdmf_common/DynamicTableRegion.html 
% *DynamicTableRegion*> object as a column of a <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*>. This is analogous to a foreign key in a relational database. 
% The <file:///Users/cesar/Repositories/matnwb/doc/+types/+hdmf_common/DynamicTableRegion.html 
% *DynamicTableRegion*> class takes in an |ObjectView| object as argument. |ObjectView| 
% objects create links from one object type referencing another.

dtr_col = types.hdmf_common.DynamicTableRegion( ...
    'description', 'references multiple rows of earlier table', ...
    'data', [0; 1; 1; 0], ...  # 0-indexed
    'table',types.untyped.ObjectView(my_table) ...  % object view of target table
);

data_col = types.hdmf_common.VectorData( ...
    'description', 'data column', ...
    'data', {'a'; 'b'; 'c'; 'd'} ...
);

dtr_table = types.hdmf_common.DynamicTable( ...
    'description', 'test table with DynamicTableRegion', ...
    'colnames', {'data_col', 'dtr_col'}, ...
    'dtr_col', dtr_col, ...
    'data_col',data_col, ...
    'id',types.hdmf_common.ElementIdentifiers('data', [0; 1; 2; 3]) ...
);
%% Converting a <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html *DynamicTable*> *to a MATLAB table*
% You can convert a <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> object to a MATLAB table by making use of the object's |toTable| 
% method. This is a useful way to view the whole table in a human-readable format.

my_table.toTable()
%% 
% When the <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> object contains a column that references other tables, you can 
% pass in a Boolean to indicate whether to include just the row indices of the 
% referenced table. Passing in |false| will result in inclusion of the referenced 
% rows as nested tables.

dtr_table.toTable(false)
%% Creating an expandable table
% When using the default HDF5 backend, each column of these tables is an HDF5 
% Dataset, which by default are set to an unchangeable size. This means that once 
% a file is written, it is not possible to add a new row. If you want to be able 
% to save this file, load it, and add more rows to the table, you will need to 
% set this up when you create the <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/VectorData.html 
% *VectorData*> and <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/ElementIdentifiers.html 
% *ElementIdentifiers*> columns of a <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*>*.* Specifically, you must wrap the column data with a *DataPipe* 
% object. The *DataPipe* class takes in maxSize and axis as arguments to indicate 
% the maximum desired size for each axis and the axis to which to append to, respectively. 
% For example, creating a *DataPipe* object with a _maxSize_ value equal to |[Inf, 
% 1]| indicates that the number of rows may increase indifinetely. In contrast, 
% setting _maxSize_  equal to |[8, 1]| would allow the column to grow to a maximum 
% height of 8.

% create NwbFile object with required fields
file= NwbFile( ...
    'session_start_time', datetime('2021-01-01 00:00:00', 'TimeZone', 'local'), ...
    'identifier', 'ident1', ...
    'session_description', 'ExpandableTableTutorial' ...
    );

% create VectorData objects with DataPipe objects
start_time_exp = types.hdmf_common.VectorData( ...
    'description', 'start times column', ...
    'data', types.untyped.DataPipe( ...
        'data', [1, 2], ...  # data must be numerical
        'maxSize', Inf ...
    ) ...
);

stop_time_exp = types.hdmf_common.VectorData( ...
    'description', 'stop times column', ...
    'data', types.untyped.DataPipe( ...
        'data', [2, 3], ...  #data must be numerical
        'maxSize', Inf ...
    ) ...
);

random_exp = types.hdmf_common.VectorData( ...
    'description', 'random data column', ...
    'data', types.untyped.DataPipe( ...
        'data', rand(5, 2), ...  #data must be numerical
        'maxSize', [5, Inf], ...
        'axis', 2 ...
    ) ...
);

ids_exp = types.hdmf_common.ElementIdentifiers( ...
    'data', types.untyped.DataPipe( ...
        'data', int32([0; 1]), ...  # data must be numerical
        'maxSize', Inf ...
    ) ...
);
% create expandable table
colnames = {'start_time', 'stop_time', 'randomvalues'};
file.intervals_trials = types.core.TimeIntervals( ...
    'description', 'test expdandable dynamic table', ...
    'colnames', colnames, ...
    'start_time', start_time_exp, ...
    'stop_time', stop_time_exp, ...
    'randomvalues', random_exp, ...
    'id', ids_exp ...
);  
% export file
nwbExport(file, 'expandableTableTestFile.nwb');
%% 
% Now, you can read in the file, add more rows, and save again to file

readFile = nwbRead('expandableTableTestFile.nwb', 'ignorecache');
readFile.intervals_trials.addRow( ...
    'start_time', 3, ...
    'stop_time', 4, ...
    'randomvalues', rand(5,1), ...
    'id', 2 ...
    )
nwbExport(readFile, 'expandableTableTestFile.nwb');
%% 
% *Note: DataPipe* objects change how the dimension of the datasets for each 
% column map onto the shape of HDF5 datasets. See <https://github.com/NeurodataWithoutBorders/matnwb#Data-Dimensions 
% README>  for more details.
%% Multidimensional Columns
% The order of dimensions of multidimensional columns in MatNWB is reversed 
% relative to the Python HDMF package (see <https://github.com/NeurodataWithoutBorders/matnwb#Data-Dimensions 
% README>  for detailed explanation). Therefore, the height of a multidimensional 
% column belonging to a <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> object is defined by the shape of its last dimension. A valid 
% <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> must have matched height across columns.
% Constructing multidimensional columns

% Define 1D column
simple_col = types.hdmf_common.VectorData( ...
    'description', '1D column',...
    'data', rand(10,1) ...
);
% Define ND column
multi_col = types.hdmf_common.VectorData( ...
    'description', 'multidimensional column',...
    'data', rand(3,2,10) ...
);
% construct table
multi_dim_table = types.hdmf_common.DynamicTable( ...
    'description','test table', ...
    'colnames', {'simple','multi'}, ...
    'simple', simple_col, ...
    'multi', multi_col, ...
    'id', types.hdmf_common.ElementIdentifiers('data', (0:9)') ...  % 0-indexed, for compatibility with Python
);

% Multidimensional ragged array columns
% <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> objects with multidimensional ragged array columns can be constructed 
% by passing in the corresponding <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/VectorIndex.html 
% *VectorIndex*> column

% Define column with data
multi_ragged_col = types.hdmf_common.VectorData( ...
    'description', 'multidimensional ragged array column',...
    'data', rand(2,3,5) ...
);
% Define column with VectorIndex
multi_ragged_index = types.hdmf_common.VectorIndex( ...
    'description', 'index to multi_ragged_col', ...
    'target', types.untyped.ObjectView(multi_ragged_col),'data', [2; 3; 5] ...
);

multi_ragged_table = types.hdmf_common.DynamicTable( ...
    'description','test table', ...
    'colnames', {'multi_ragged'}, ...
    'multi_ragged', multi_ragged_col, ...
    'multi_ragged_index', multi_ragged_index, ...
    'id', types.hdmf_common.ElementIdentifiers('data', [0; 1; 2]) ...  % 0-indexed, for compatibility with Python
);
% Adding rows to multidimensional array columns
% <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> objects with multidimensional array columns can also be constructed 
% by adding a single row at a time. This method makes use of *DataPipe* objects 
% due to the fact that MATLAB doesn't support singleton dimensions for arrays 
% with more than 2 dimensions. The code block below demonstrates how to build 
% a <https://neurodatawithoutborders.github.io/matnwb/doc/+types/+hdmf_common/DynamicTable.html 
% *DynamicTable*> object with a mutidimensional raaged array column in this manner.

% Create file
file = NwbFile( ...
    'session_start_time', datetime('2021-01-01 00:00:00', 'TimeZone', 'local'), ...
    'identifier', 'ident1', ...
    'session_description', 'test_file' ...
    );

% Define Vector Data Objects with first row of table
start_time_exp = types.hdmf_common.VectorData( ...
    'description', 'start times column', ...
    'data', types.untyped.DataPipe( ...
        'data', 1, ...  
        'maxSize', Inf ...
    ) ...
);
stop_time_exp = types.hdmf_common.VectorData( ...
    'description', 'stop times column', ...
    'data', types.untyped.DataPipe( ...
        'data', 10, ...  
        'maxSize', Inf ...
    ) ...
);
random_exp = types.hdmf_common.VectorData( ...
    'description', 'random data column', ...
    'data', types.untyped.DataPipe( ...
        'data', rand(3,2,5), ...  #random data
        'maxSize', [3, 2, Inf], ...
        'axis', 3 ...
    ) ...
);
random_exp_index = types.hdmf_common.VectorIndex( ...
    'description', 'index to random data column', ...
     'target',types.untyped.ObjectView(random_exp), ...
    'data', types.untyped.DataPipe( ...
        'data', uint64(5), ...  
        'maxSize', Inf ...
    ) ...
);
ids_exp = types.hdmf_common.ElementIdentifiers( ...
    'data', types.untyped.DataPipe( ...
        'data', int64(0), ...  # data must be numerical
        'maxSize', Inf ...
    ) ...
);
% Create expandable table
colnames = {'start_time', 'stop_time', 'randomvalues'};
file.intervals_trials = types.core.TimeIntervals( ...
    'description', 'test expdandable dynamic table', ...
    'colnames', colnames, ...
    'start_time', start_time_exp, ...
    'stop_time', stop_time_exp, ...
    'randomvalues', random_exp, ...
    'randomvalues_index', random_exp_index, ...
    'id', ids_exp ...
);  
% Export file
nwbExport(file, 'multiRaggedExpandableTableTest.nwb');
% Read in file
read_file = nwbRead('multiRaggedExpandableTableTest.nwb', 'ignorecache');
% add individual rows
read_file.intervals_trials.addRow( ...
    'start_time', 2, ...
    'stop_time', 20, ...
    'randomvalues', rand(3,2,6), ...
    'id', 1 ...
);
read_file.intervals_trials.addRow( ...
    'start_time', 3, ...
    'stop_time', 30, ...
    'randomvalues', rand(3,2,3), ...
    'id', 2 ...
);
read_file.intervals_trials.addRow( ...
    'start_time', 4, ...
    'stop_time', 40, ...
    'randomvalues', rand(3,2,8), ...
    'id', 3 ...
);

%% 
%% Learn More!
% Python Tutorial
% <https://hdmf.readthedocs.io/en/stable/tutorials/plot_dynamictable_tutorial.html#sphx-glr-tutorials-plot-dynamictable-tutorial-py 
% DynamicTable Tutorial>
% 
%