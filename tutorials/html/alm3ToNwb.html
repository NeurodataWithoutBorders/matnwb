
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>NWB File Conversion Tutorial</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-12-28"><meta name="DC.source" content="alm3ToNwb.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>NWB File Conversion Tutorial</h1><!--introduction--><p>How to convert trial-based experimental data to the Neurodata Without Borders file format using MatNWB. This example uses the <a href="https://crcns.org/data-sets/motor-cortex/alm-3">CRCNS ALM-3</a> data set.  Information on how to download the data can be found on the <a href="https://crcns.org/data-sets/motor-cortex/download">CRCNS Download Page</a>.  One should first familiarize themselves with the file format, which can be found on the <a href="https://crcns.org/data-sets/motor-cortex/alm-3/about-alm-3">ALM-3 About Page</a> under the Documentation files.</p><pre>author: Lawrence Niu
contact: lawrence@vidriotech.com
last updated: Dec 27, 2018</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Script Configuration</a></li><li><a href="#4">General Information</a></li><li><a href="#6">File Overview</a></li><li><a href="#7">Metadata</a></li><li><a href="#13">Data Structures and Hashes</a></li><li><a href="#20">Raw Acquisition Data</a></li><li><a href="#21">Export</a></li></ul></div><h2 id="1">Script Configuration</h2><p>The following details configuration information specific to this script.  Parameters can be changed to fit any of the available sessions.</p><p>The animal and session specifier can be changed below with the <b>animal</b> and <b>session</b> variable name respectively.  <b>metadata_loc</b>, <b>datastructure_loc</b>, and <b>rawdata_loc</b> should refer to: the metadata .mat file, the data structure .mat file, and the raw .tar file.</p><pre class="codeinput">animal = <span class="string">'ANM255200'</span>;
session = <span class="string">'20140910'</span>;

identifier = [animal <span class="string">'_'</span> session];

metadata_loc = fullfile(<span class="string">'data'</span>,<span class="string">'metadata'</span>, [<span class="string">'meta_data_'</span> identifier <span class="string">'.mat'</span>]);
datastructure_loc = fullfile(<span class="string">'data'</span>,<span class="string">'data_structure_files'</span>,<span class="keyword">...</span>
    [<span class="string">'data_structure_'</span> identifier <span class="string">'.mat'</span>]);
rawdata_loc = fullfile(<span class="string">'data'</span>, <span class="string">'RawVoltageTraces'</span>, [identifier <span class="string">'.tar'</span>]);
</pre><p>The NWB file will be saved in the output directory indicated by <b>outdir</b></p><pre class="codeinput">outloc = <span class="string">'out'</span>;

<span class="keyword">if</span> 7 ~= exist(outloc, <span class="string">'dir'</span>)
    mkdir(outloc);
<span class="keyword">end</span>

source_file = [mfilename() <span class="string">'.m'</span>];
[~, source_script, ~] = fileparts(source_file);
</pre><h2 id="4">General Information</h2><p>The first thing we fill out are general experiment context information.  The only required information here is the identifier, which distinguishes one session from another.  The ALM-3 data is separated by session date and experimented animal ID so we will do the same with our identifier.</p><p>Not all general information can be found in the data files.  Certain properties like keywords, institutions, and related publications were derived from the published paper.</p><pre class="codeinput">nwb = nwbfile();
nwb.identifier = identifier;
nwb.general_source_script = source_script;
nwb.general_source_script_file_name = source_file;
nwb.general_lab = <span class="string">'Svoboda'</span>;
nwb.general_keywords = {<span class="string">'Network models'</span>, <span class="string">'Premotor cortex'</span>, <span class="string">'Short-term memory'</span>};
nwb.general_institution = [<span class="string">'Janelia Research Campus,'</span><span class="keyword">...</span>
    <span class="string">' Howard Huges Medical Institute, Ashburn, Virginia 20147, USA'</span>];
nwb.general_related_publications = <span class="keyword">...</span>
    [<span class="string">'Li N, Daie K, Svoboda K, Druckmann S (2016).'</span>,<span class="keyword">...</span>
    <span class="string">' Robust neuronal dynamics in premotor cortex during motor planning.'</span>,<span class="keyword">...</span>
    <span class="string">' Nature. 7600:459-64. doi: 10.1038/nature17643'</span>];
nwb.general_stimulus = <span class="string">'photostim'</span>;
nwb.general_protocol = <span class="string">'IACUC'</span>;
nwb.general_surgery = [<span class="string">'Mice were prepared for photoinhibition and '</span>,<span class="keyword">...</span>
    <span class="string">'electrophysiology with a clear-skull cap and a headpost. '</span>,<span class="keyword">...</span>
    <span class="string">'The scalp and periosteum over the dorsal surface of the skull were removed. '</span>,<span class="keyword">...</span>
    <span class="string">'A layer of cyanoacrylate adhesive (Krazy glue, Elmer&#8217;s Products Inc.) '</span>,<span class="keyword">...</span>
    <span class="string">'was directly applied to the intact skull. A custom made headpost '</span>,<span class="keyword">...</span>
    <span class="string">'was placed on the skull with its anterior edge aligned with the suture lambda '</span>,<span class="keyword">...</span>
    <span class="string">'(approximately over cerebellum) and cemented in place '</span>,<span class="keyword">...</span>
    <span class="string">'with clear dental acrylic (Lang Dental Jet Repair Acrylic; 1223-clear). '</span>,<span class="keyword">...</span>
    <span class="string">'A thin layer of clear dental acrylic was applied over the cyanoacrylate adhesive '</span>,<span class="keyword">...</span>
    <span class="string">'covering the entire exposed skull, '</span>,<span class="keyword">...</span>
    <span class="string">'followed by a thin layer of clear nail polish (Electron Microscopy Sciences, 72180).'</span>];
nwb.session_description = sprintf(<span class="string">'Animal `%s` on Session `%s`'</span>, animal, session);
</pre><h2 id="6">File Overview</h2><p>Each session has three files: a metadata .mat file describing the experiment, the data structures .mat file containing trial/analysis data, and the raw data .tar file containing the raw electrophysiology data separated by trial.</p><h2 id="7">Metadata</h2><p>ALM-3 Metadata contains information about the reference times, experimental context, methodology, as well as details of the electrophysiology, optophysiology, and behavioral portions of the experiment.  A vast majority of these details will be placed in the <i>general</i> subgroup in NWB.</p><pre class="codeinput">loaded = load(metadata_loc, <span class="string">'meta_data'</span>);
meta = loaded.meta_data;

<span class="comment">%experiment-specific treatment for animals with the ReaChR gene modification</span>
isreachr = any(cell2mat(strfind(meta.animalGeneModification, <span class="string">'ReaChR'</span>)));

<span class="comment">%sessions are separated by date of experiment.</span>
nwb.general_session_id = meta.dateOfExperiment;

<span class="comment">%ALM-3 data start time is reference time.</span>
nwb.session_start_time = datetime([meta.dateOfExperiment meta.timeOfExperiment],<span class="keyword">...</span>
    <span class="string">'InputFormat'</span>, <span class="string">'yyyyMMddHHmmss'</span>);
nwb.timestamps_reference_time = nwb.session_start_time;

nwb.general_experimenter = strjoin(meta.experimenters, <span class="string">', '</span>);
</pre><p>Ideally, if a raw data field does not correspond directly to a NWB field, one would create their own using a <a href="https://pynwb.readthedocs.io/en/latest/extensions.html">custom NWB extension class</a>. To keep this tutorial simple, we instead pack the extra values into the <i>description</i> field as a string, which works with miscellaneous configuration parameters such as these.</p><pre class="codeinput">nwb.general_subject = types.core.Subject(<span class="keyword">...</span>
    <span class="string">'species'</span>, meta.species{1}, <span class="keyword">...</span>
    <span class="string">'subject_id'</span>, meta.animalID{1}(1,:), <span class="keyword">...</span><span class="comment"> %weird case with duplicate Animal ID</span>
    <span class="string">'sex'</span>, meta.sex, <span class="keyword">...</span>
    <span class="string">'age'</span>, meta.dateOfBirth, <span class="keyword">...</span>
    <span class="string">'description'</span>, [<span class="keyword">...</span>
        <span class="string">'Whisker Config: '</span> strjoin(meta.whiskerConfig, <span class="string">', '</span>) newline<span class="keyword">...</span>
        <span class="string">'Animal Source: '</span> strjoin(meta.animalSource, <span class="string">', '</span>)]);

<span class="comment">%formatStruct simply prints the field and values given the struct.  Optional cell</span>
<span class="comment">%array of field names specifies whitelist of fields to print.</span>
nwb.general_subject.genotype = formatStruct(<span class="keyword">...</span>
    meta, <span class="keyword">...</span>
    {<span class="string">'animalStrain'</span>; <span class="string">'animalGeneModification'</span>; <span class="string">'animalGeneCopy'</span>;<span class="keyword">...</span>
    <span class="string">'animalGeneticBackground'</span>});

weight = {};
<span class="keyword">if</span> ~isempty(meta.weightBefore)
    weight{end+1} = <span class="string">'weightBefore'</span>;
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(meta.weightAfter)
    weight{end+1} = <span class="string">'weightAfter'</span>;
<span class="keyword">end</span>
weight = weight(~cellfun(<span class="string">'isempty'</span>, weight));
<span class="keyword">if</span> ~isempty(weight)
    nwb.general_subject.weight = formatStruct(meta, weight);
<span class="keyword">end</span>

<span class="comment">% general/experiment_description</span>
nwb.general_experiment_description = [<span class="keyword">...</span>
    formatStruct(meta, {<span class="string">'experimentType'</span>; <span class="string">'referenceAtlas'</span>}), <span class="keyword">...</span>
    sprintf(<span class="string">'\n'</span>), <span class="keyword">...</span>
    formatStruct(meta.behavior, {<span class="string">'task_keyword'</span>})];

<span class="comment">% Miscellaneous collection information from ALM-3 that didn't quite fit any NWB properties</span>
<span class="comment">% are stored in general/data_collection.</span>
nwb.general_data_collection = formatStruct(meta.extracellular,<span class="keyword">...</span>
    {<span class="string">'extracellularDataType'</span>;<span class="string">'cellType'</span>;<span class="string">'identificationMethod'</span>;<span class="string">'amplifierRolloff'</span>;<span class="keyword">...</span>
    <span class="string">'spikeSorting'</span>;<span class="string">'ADunit'</span>});

<span class="comment">% Device objects are essentially just a list of device names.  We store the probe</span>
<span class="comment">% and laser hardware names here.</span>
probetype = meta.extracellular.probeType{1};
probeSource = meta.extracellular.probeSource{1};
nwb.general_devices.set([probetype <span class="string">' ('</span> probeSource <span class="string">')'</span>],<span class="keyword">...</span>
    types.core.Device());

<span class="keyword">if</span> isreachr
    laserName = <span class="string">'laser-594nm (Cobolt Inc., Cobolt Mambo 100)'</span>;
<span class="keyword">else</span>
    laserName = <span class="string">'laser-473nm (Laser Quantum, Gem 473)'</span>;
<span class="keyword">end</span>
nwb.general_devices.set(laserName, types.core.Device());
</pre><p>The NWB <b>ElectrodeGroup</b> object stores experimental information regarding a group of probes (presumably defined in the <b>Device</b> section).  The object requires a <b>SoftLink</b> to the probe specified under <i>devices</i>. SoftLink objects are direct maps to <a href="https://portal.hdfgroup.org/display/HDF5/H5L_CREATE_SOFT">HDF5 Soft Links</a> on export, and thus, require a true HDF5 path.</p><pre class="codeinput">structDesc = {<span class="string">'recordingCoordinates'</span>;<span class="string">'recordingMarker'</span>;<span class="string">'recordingType'</span>;<span class="string">'penetrationN'</span>;<span class="keyword">...</span>
    <span class="string">'groundCoordinates'</span>};
<span class="keyword">if</span> ~isempty(meta.extracellular.referenceCoordinates)
    structDesc{end+1} = <span class="string">'referenceCoordinates'</span>;
<span class="keyword">end</span>
recordingLocation = meta.extracellular.recordingLocation{1};
egroup = types.core.ElectrodeGroup(<span class="keyword">...</span>
    <span class="string">'description'</span>, formatStruct(meta.extracellular, structDesc),<span class="keyword">...</span>
    <span class="string">'location'</span>, recordingLocation,<span class="keyword">...</span>
    <span class="string">'device'</span>, types.untyped.SoftLink([<span class="string">'/general/devices/'</span> probetype]));
nwb.general_extracellular_ephys.set(probetype, egroup);
egroupPath = [<span class="string">'/general/extracellular_ephys/'</span> probetype];
</pre><p>The <i>electrodes</i> property in <i>extracellular_ephys</i> is a special keyword in NWB that must be paired with a <b>Dynamic Table</b>.  These are tables which can have an unbounded number of columns and rows, each as their own dataset.  With the exception of <i>id</i>, all columns must be <b>VectorData</b> or <b>VectorIndex</b> objects.  The <i>id</i> column, meanwhile, must be an <b>ElementIdentifiers</b> object. The names of all used columns are specified in the in the <i>colnames</i> property as a cell array of strings.</p><p>The <i>group</i> column in the Dynamic Table contains an <b>ObjectView</b> to the ElectrodeGroup created above.  An ObjectView can be best thought of as a direct pointer to another typed object.  It also directly maps to a <a href="https://portal.hdfgroup.org/display/HDF5/H5R_CREATE">HDF5 Object Reference</a> , thus the HDF5 path requirement.  ObjectViews are slightly different from SoftLinks in that they can be stored in datasets (data columns, tables, and <i>data</i> fields in <b>NWBData</b> objects).</p><pre class="codeinput">etrodeNum = length(meta.extracellular.siteLocations);
etrodeMat = cell2mat(meta.extracellular.siteLocations .');
emptyStr = repmat({<span class="string">''</span>}, etrodeNum,1);
dtColNames = {<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>, <span class="string">'imp'</span>, <span class="string">'location'</span>, <span class="string">'description'</span>, <span class="string">'filtering'</span>,<span class="string">'group'</span>,<span class="keyword">...</span>
    <span class="string">'group_name'</span>};
<span class="comment">% you can specify column names and values as key-value arguments in the DynamicTable</span>
<span class="comment">% constructor.</span>
dynTable = types.core.DynamicTable(<span class="keyword">...</span>
    <span class="string">'colnames'</span>, dtColNames,<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'Electrodes'</span>,<span class="keyword">...</span>
    <span class="string">'id'</span>, types.core.ElementIdentifiers(<span class="string">'data'</span>, int64(1:etrodeNum)),<span class="keyword">...</span>
    <span class="string">'x'</span>, types.core.VectorData(<span class="string">'data'</span>, etrodeMat(:,1),<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'the x coordinate of the channel location'</span>),<span class="keyword">...</span>
    <span class="string">'y'</span>, types.core.VectorData(<span class="string">'data'</span>, etrodeMat(:,2),<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'the y coordinate of the channel location'</span>),<span class="keyword">...</span>
    <span class="string">'z'</span>, types.core.VectorData(<span class="string">'data'</span>, etrodeMat(:,3),<span class="keyword">...</span>
        <span class="string">'description'</span>,<span class="string">'the z coordinate of the channel location'</span>),<span class="keyword">...</span>
    <span class="string">'imp'</span>, types.core.VectorData(<span class="string">'data'</span>, zeros(etrodeNum,1),<span class="keyword">...</span>
        <span class="string">'description'</span>,<span class="string">'the impedance of the channel'</span>),<span class="keyword">...</span>
    <span class="string">'location'</span>, types.core.VectorData(<span class="string">'data'</span>,<span class="keyword">...</span>
        repmat({recordingLocation}, etrodeNum, 1),<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'the location of channel within the subject e.g. brain region'</span>),<span class="keyword">...</span>
    <span class="string">'filtering'</span>, types.core.VectorData(<span class="string">'data'</span>, emptyStr,<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'description of hardware filtering'</span>),<span class="keyword">...</span>
    <span class="string">'group'</span>, types.core.VectorData(<span class="string">'data'</span>,<span class="keyword">...</span>
        repmat(types.untyped.ObjectView(egroupPath), etrodeNum, 1),<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'a reference to the ElectrodeGroup this electrode is a part of'</span>),<span class="keyword">...</span>
    <span class="string">'group_name'</span>, types.core.VectorData(<span class="string">'data'</span>, repmat({probetype}, etrodeNum, 1),<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'the name of the ElectrodeGroup this electrode is a part of'</span>));
nwb.general_extracellular_ephys.set(<span class="string">'electrodes'</span>, dynTable);
</pre><pre class="codeinput"><span class="comment">% general/optogenetics/photostim</span>
nwb.general_optogenetics.set(<span class="string">'photostim'</span>, <span class="keyword">...</span>
    types.core.OptogeneticStimulusSite(<span class="keyword">...</span>
    <span class="string">'excitation_lambda'</span>, num2str(meta.photostim.photostimWavelength{1}), <span class="keyword">...</span>
    <span class="string">'location'</span>, meta.photostim.photostimLocation{1}, <span class="keyword">...</span>
    <span class="string">'device'</span>, laserName, <span class="keyword">...</span>
    <span class="string">'description'</span>, formatStruct(meta.photostim, {<span class="keyword">...</span>
    <span class="string">'stimulationMethod'</span>;<span class="string">'photostimCoordinates'</span>;<span class="string">'identificationMethod'</span>})));
</pre><h2 id="13">Data Structures and Hashes</h2><p>ALM-3 stores its data structures in the form of <b>Hashes</b> which are essentially the same as Dictionaries or containers.Maps but where the keys and values are stored under separate struct fields.  Getting a "hashed" value from a key involves retrieving the array index that the key is in and applying it to the parallel array in the values field.  In that way, it's fairly simple to convert from Hashes to equivalent Sets or Dynamic Tables.</p><p>You can find more information about Hashes and how they're used on the <a href="https://crcns.org/data-sets/motor-cortex/alm-3/about-alm-3">ALM-3 about page</a>.</p><pre class="codeinput">loaded = load(datastructure_loc, <span class="string">'obj'</span>);
data = loaded.obj;
</pre><p>NWB comes with default support for trial-based data.  These must be <b>TimeIntervals</b> that are placed in the <i>intervals</i> property in NWB.  Note that <i>trials</i> is a special keyword that is required for pyNWB compatibility.</p><pre class="codeinput">trials = types.core.TimeIntervals(<span class="keyword">...</span>
    <span class="string">'start_time'</span>, types.core.VectorData(<span class="string">'data'</span>, data.trialStartTimes,<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'the start time of each trial'</span>),<span class="keyword">...</span>
    <span class="string">'colnames'</span>, [data.trialTypeStr; data.trialPropertiesHash.keyNames .'],<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'trial data and properties'</span>, <span class="keyword">...</span>
    <span class="string">'id'</span>, types.core.ElementIdentifiers(<span class="string">'data'</span>, data.trialIds));
<span class="keyword">for</span> i=1:length(data.trialTypeStr)
    trials.vectordata.set(data.trialTypeStr{i}, <span class="keyword">...</span>
        types.core.VectorData(<span class="string">'data'</span>, data.trialTypeMat(i,:),<span class="keyword">...</span>
            <span class="string">'description'</span>, data.trialTypeStr{i}));
<span class="keyword">end</span>

<span class="keyword">for</span> i=1:length(data.trialPropertiesHash.keyNames)
    trials.vectordata.set(data.trialPropertiesHash.keyNames{i}, <span class="keyword">...</span>
        types.core.VectorData(<span class="keyword">...</span>
        <span class="string">'data'</span>, data.trialPropertiesHash.value{i}, <span class="keyword">...</span>
        <span class="string">'description'</span>, data.trialPropertiesHash.descr{i}));
<span class="keyword">end</span>
nwb.intervals.set(<span class="string">'trials'</span>, trials); <span class="comment">%MUST be called `trials` for pynwb compatibility</span>

ephus = data.timeSeriesArrayHash.value{1};
ephusUnit = data.timeUnitNames{data.timeUnitIds(ephus.timeUnit)};
</pre><p>Ephus behavioral data is stored in separate NWB locations:</p><div><ul><li>Lick trace data is stored in <i>acquisition</i> under <i>lick_trace</i></li><li>AOM input trace and laser power are stored in <i>stimulus/presentation</i> as <i>aom_input_trace</i> and <i>laser_power</i> respectively.</li></ul></div><p>Trial IDs, wherever they are used, will be placed in a relevent <i>control</i> property in the data object and will indicate what data is associated with what trial as defined in the trials id column.</p><pre class="codeinput"><span class="comment">% lick_trace</span>
tsIdx = strcmp(ephus.idStr, <span class="string">'lick_trace'</span>);
bts = types.core.BehavioralTimeSeries();
bts.timeseries.set(<span class="string">'lick_trace_ts'</span>, <span class="keyword">...</span>
    types.core.TimeSeries(<span class="keyword">...</span>
    <span class="string">'control'</span>, ephus.trial, <span class="keyword">...</span>
    <span class="string">'control_description'</span>, <span class="string">'trial index'</span>, <span class="keyword">...</span>
    <span class="string">'data'</span>, ephus.valueMatrix(:,tsIdx),<span class="keyword">...</span>
    <span class="string">'data_unit'</span>, ephusUnit,<span class="keyword">...</span>
    <span class="string">'description'</span>, ephus.idStrDetailed{tsIdx}, <span class="keyword">...</span>
    <span class="string">'timestamps'</span>, ephus.time, <span class="keyword">...</span>
    <span class="string">'timestamps_unit'</span>, ephusUnit));
nwb.acquisition.set(<span class="string">'lick_trace'</span>, bts);

<span class="comment">% aom</span>
tsIdx = strcmp(ephus.idStr, <span class="string">'aom_input_trace'</span>);
ts = types.core.TimeSeries(<span class="keyword">...</span>
    <span class="string">'control'</span>, ephus.trial, <span class="keyword">...</span>
    <span class="string">'control_description'</span>, <span class="string">'trial index'</span>, <span class="keyword">...</span>
    <span class="string">'data'</span>, ephus.valueMatrix(:,tsIdx), <span class="keyword">...</span>
    <span class="string">'data_unit'</span>, <span class="string">'Volts'</span>, <span class="keyword">...</span>
    <span class="string">'description'</span>, ephus.idStrDetailed{tsIdx}, <span class="keyword">...</span>
    <span class="string">'timestamps'</span>, ephus.time, <span class="keyword">...</span>
    <span class="string">'timestamps_unit'</span>, ephusUnit);
nwb.stimulus_presentation.set(<span class="string">'aom_input_trace'</span>, ts);
<span class="comment">% laser_power</span>
tsIdx = strcmp(ephus.idStr, <span class="string">'laser_power'</span>);
ots = types.core.OptogeneticSeries(<span class="keyword">...</span>
    <span class="string">'control'</span>, ephus.trial, <span class="keyword">...</span>
    <span class="string">'control_description'</span>, <span class="string">'trial index'</span>, <span class="keyword">...</span>
    <span class="string">'data'</span>, ephus.valueMatrix(:,tsIdx), <span class="keyword">...</span>
    <span class="string">'data_unit'</span>, <span class="string">'mW'</span>, <span class="keyword">...</span>
    <span class="string">'description'</span>, ephus.idStrDetailed{tsIdx}, <span class="keyword">...</span>
    <span class="string">'timestamps'</span>, ephus.time, <span class="keyword">...</span>
    <span class="string">'timestamps_unit'</span>, ephusUnit, <span class="keyword">...</span>
    <span class="string">'site'</span>, types.untyped.SoftLink(<span class="string">'/general/optogenetics/photostim'</span>));
nwb.stimulus_presentation.set(<span class="string">'laser_power'</span>, ots);
</pre><p>Ephus spike data is separated into units which directly maps to the NWB property of the same name.  Each such unit contains a group of analysed waveforms and spike times, all linked to a different subset of trials IDs.  The waveforms are placed in the <i>analysis</i> Set and are paired with their unit name ('unitx' where 'x' is some unit ID).  The spike times and trial IDs are kept in the <b>Units</b> object (under the <i>units</i> property) along with references to the <i>analysis</i> waveforms. To better how <i>spike_times_index</i> and <i>spike_times</i> map to each other, refer to <a href="https://neurodatawithoutborders.github.io/matnwb/tutorials/html/ecephys.html#13">this diagram</a> from the Extracellular Electrophysiology Tutorial.</p><p>To index the relevent trial IDs, The <i>trials</i> column uses <b>RegionView</b> objects. RegionViews are ObjectViews with extra embedded indexing information which allows for referring to subsets of data within a dataset.</p><p><b>NOTE</b>: To reference indices in dynamic tables such as <i>intervals/trials</i>, the raw HDF5 path must point to the column (<i>intervals/trials/id</i> in this case).</p><pre class="codeinput">nwb.units = types.core.Units(<span class="string">'colnames'</span>,<span class="keyword">...</span>
    {<span class="string">'spike_times_index'</span>, <span class="string">'spike_times'</span>, <span class="string">'trials'</span>, <span class="string">'waveforms'</span>},<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'Analysed Spike Events'</span>);
esHash = data.eventSeriesHash;
ids = regexp(esHash.keyNames, <span class="string">'^unit(\d+)$'</span>, <span class="string">'once'</span>, <span class="string">'tokens'</span>);
ids = str2double([ids{:}]);
nwb.units.id = types.core.ElementIdentifiers(<span class="string">'data'</span>, ids);
nwb.units.spike_times_index = types.core.VectorIndex(<span class="keyword">...</span>
    <span class="string">'data'</span>, types.untyped.RegionView.empty,<span class="keyword">...</span>
    <span class="string">'target'</span>, types.untyped.ObjectView(<span class="string">'/units/spike_times'</span>));
nwb.units.spike_times = types.core.VectorData(<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'timestamps of spikes'</span>);
trials = types.core.VectorIndex(<span class="keyword">...</span>
    <span class="string">'data'</span>, types.untyped.RegionView.empty,<span class="keyword">...</span>
    <span class="string">'target'</span>, types.untyped.ObjectView(<span class="string">'/intervals/trials'</span>));
wav_idx = types.core.VectorData(<span class="string">'data'</span>,types.untyped.ObjectView.empty,<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'waveform references'</span>);
trial_ids = nwb.intervals.get(<span class="string">'trials'</span>).id.data;
<span class="keyword">for</span> i=1:length(ids)
    esData = esHash.value{i};
    trials.data(end+1) = types.untyped.RegionView(<span class="string">'/intervals/trials/id'</span>,<span class="keyword">...</span>
        trial_ids == esData.eventTrials);

    nwb.units.spike_times_index.data(end+1) = <span class="keyword">...</span>
        types.untyped.RegionView(<span class="string">'/units/spike_times'</span>,<span class="keyword">...</span>
        length(nwb.units.spike_times.data) + (1:length(esData.eventTimes)));
    nwb.units.spike_times.data = [nwb.units.spike_times.data;esData.eventTimes];

    ses = types.core.SpikeEventSeries(<span class="keyword">...</span>
        <span class="string">'control'</span>, esData.eventTrials,<span class="keyword">...</span>
        <span class="string">'control_description'</span>, <span class="string">'trial indices'</span>, <span class="keyword">...</span>
        <span class="string">'data'</span>, esData.waveforms, <span class="keyword">...</span>
        <span class="string">'description'</span>, esHash.descr{i}, <span class="keyword">...</span>
        <span class="string">'timestamps'</span>, esData.eventTimes, <span class="keyword">...</span>
        <span class="string">'timestamps_unit'</span>, data.timeUnitNames{data.timeUnitIds(esData.timeUnit)},<span class="keyword">...</span>
        <span class="string">'electrodes'</span>, types.core.DynamicTableRegion(<span class="keyword">...</span>
            <span class="string">'description'</span>, <span class="string">'Electrodes involved with these spike events'</span>,<span class="keyword">...</span>
            <span class="string">'table'</span>, types.untyped.ObjectView(<span class="string">'/general/extracellular_ephys/electrodes'</span>),<span class="keyword">...</span>
            <span class="string">'data'</span>, esData.channel));
    <span class="keyword">if</span> ~isempty(esData.cellType)
        ses.comments = [<span class="string">'cellType: '</span> esData.cellType{1}];
    <span class="keyword">end</span>
    nwb.analysis.set(esHash.keyNames{i}, ses);
    wav_idx.data(end+1) = types.untyped.ObjectView([<span class="string">'/analysis/'</span> esHash.keyNames{i}]);
<span class="keyword">end</span>
nwb.units.vectorindex.set(<span class="string">'trials'</span>, trials);
nwb.units.vectordata.set(<span class="string">'waveforms'</span>, wav_idx);
</pre><h2 id="20">Raw Acquisition Data</h2><p>Each ALM-3 session is associated with a large number of raw voltage data grouped by trial ID. To map this data to NWB, each trial is created as its own <b>ElectricalSeries</b> object under the name 'trial n' where 'n' is the trial ID.</p><pre class="codeinput">untarLoc = fullfile(pwd, identifier);
<span class="keyword">if</span> 7 ~= exist(untarLoc, <span class="string">'dir'</span>)
    untar(rawdata_loc, pwd);
<span class="keyword">end</span>

rawfiles = dir(untarLoc);
rawfiles = fullfile(untarLoc, {rawfiles(~[rawfiles.isdir]).name});

nrows = length(nwb.general_extracellular_ephys.get(<span class="string">'electrodes'</span>).id.data);
tablereg = types.core.DynamicTableRegion(<span class="keyword">...</span>
    <span class="string">'description'</span>,<span class="string">'Relevent Electrodes for this Electrical Series'</span>,<span class="keyword">...</span>
    <span class="string">'table'</span>,types.untyped.ObjectView(<span class="string">'/general/extracellular_ephys/electrodes'</span>),<span class="keyword">...</span>
    <span class="string">'data'</span>,1:nrows);
objrefs = cell(size(rawfiles));
trials = nwb.intervals.get(<span class="string">'trials'</span>);
endTimestamps = trials.start_time.data;
<span class="keyword">for</span> i=1:length(rawfiles)
    tnumstr = regexp(rawfiles{i}, <span class="string">'_trial_(\d+)\.mat$'</span>, <span class="string">'tokens'</span>, <span class="string">'once'</span>);
    tnumstr = tnumstr{1};
    rawdata = load(rawfiles{i}, <span class="string">'ch_MUA'</span>, <span class="string">'TimeStamps'</span>);
    tnum = str2double(tnumstr);
    es = types.core.ElectricalSeries(<span class="keyword">...</span>
        <span class="string">'data'</span>, rawdata.ch_MUA,<span class="keyword">...</span>
        <span class="string">'description'</span>, [<span class="string">'Raw Voltage Acquisition for trial '</span> tnumstr],<span class="keyword">...</span>
        <span class="string">'electrodes'</span>, tablereg,<span class="keyword">...</span>
        <span class="string">'timestamps'</span>, rawdata.TimeStamps);
    tname = [<span class="string">'trial '</span> tnumstr];
    nwb.acquisition.set(tname, es);
    endTimestamps(tnum) = endTimestamps(tnum) + rawdata.TimeStamps(end);
    objrefs{tnum} = types.untyped.ObjectView([<span class="string">'/acquisition/'</span> tname]);
<span class="keyword">end</span>

<span class="comment">%we then link to the raw data by adding the acquisition column with ObjectViews</span>
<span class="comment">%to the data</span>
emptyrefs = cellfun(<span class="string">'isempty'</span>, objrefs);
objrefs(emptyrefs) = {types.untyped.ObjectView(<span class="string">''</span>)};
trials.colnames{end+1} = <span class="string">'acquisition'</span>;
trials.vectordata.set(<span class="string">'acquisition'</span>, types.core.VectorData(<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'soft link to acquisition data for this trial'</span>,<span class="keyword">...</span>
    <span class="string">'data'</span>, [objrefs{:}]));
trials.stop_time = types.core.VectorData(<span class="keyword">...</span>
    <span class="string">'data'</span>, endTimestamps,<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'the end time of each trial'</span>);

rmdir(untarLoc, <span class="string">'s'</span>);
</pre><h2 id="21">Export</h2><p>Finally, we export using the 'session_animalID' notation used in the raw data files.</p><pre class="codeinput">outDest = fullfile(outloc, [identifier <span class="string">'.nwb'</span>]);
nwbExport(nwb, outDest);
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% NWB File Conversion Tutorial
% How to convert trial-based experimental data to the Neurodata Without Borders file format using MatNWB.
% This example uses the <https://crcns.org/data-sets/motor-cortex/alm-3 CRCNS ALM-3>
% data set.  Information on how to download the data can be found on the 
% <https://crcns.org/data-sets/motor-cortex/download CRCNS Download Page>.  One should
% first familiarize themselves with the file format, which can be found on the
% <https://crcns.org/data-sets/motor-cortex/alm-3/about-alm-3 ALM-3 About Page> under
% the Documentation files.
% 
%  author: Lawrence Niu
%  contact: lawrence@vidriotech.com
%  last updated: Dec 27, 2018

%% Script Configuration
% The following details configuration information specific to this script.  Parameters
% can be changed to fit any of the available sessions.
%%
% The animal and session specifier can be changed below with the *animal* and *session*
% variable name respectively.  *metadata_loc*, *datastructure_loc*, and *rawdata_loc*
% should refer to: the metadata .mat file, the data structure .mat file, 
% and the raw .tar file.
animal = 'ANM255200';
session = '20140910';

identifier = [animal '_' session];

metadata_loc = fullfile('data','metadata', ['meta_data_' identifier '.mat']);
datastructure_loc = fullfile('data','data_structure_files',...
    ['data_structure_' identifier '.mat']);
rawdata_loc = fullfile('data', 'RawVoltageTraces', [identifier '.tar']);
%%
% The NWB file will be saved in the output directory indicated by *outdir*
outloc = 'out';

if 7 ~= exist(outloc, 'dir')
    mkdir(outloc);
end

source_file = [mfilename() '.m'];
[~, source_script, ~] = fileparts(source_file);

%% General Information
% The first thing we fill out are general experiment context information.  The only
% required information here is the identifier, which distinguishes one session from
% another.  The ALM-3 data is separated by session date and experimented animal ID so
% we will do the same with our identifier.
%%
% Not all general information can be found in the data files.  Certain properties like
% keywords, institutions, and related publications were derived from the published paper.
nwb = nwbfile();
nwb.identifier = identifier;
nwb.general_source_script = source_script;
nwb.general_source_script_file_name = source_file;
nwb.general_lab = 'Svoboda';
nwb.general_keywords = {'Network models', 'Premotor cortex', 'Short-term memory'};
nwb.general_institution = ['Janelia Research Campus,'...
    ' Howard Huges Medical Institute, Ashburn, Virginia 20147, USA'];
nwb.general_related_publications = ...
    ['Li N, Daie K, Svoboda K, Druckmann S (2016).',...
    ' Robust neuronal dynamics in premotor cortex during motor planning.',...
    ' Nature. 7600:459-64. doi: 10.1038/nature17643'];
nwb.general_stimulus = 'photostim';
nwb.general_protocol = 'IACUC';
nwb.general_surgery = ['Mice were prepared for photoinhibition and ',...
    'electrophysiology with a clear-skull cap and a headpost. ',...
    'The scalp and periosteum over the dorsal surface of the skull were removed. ',...
    'A layer of cyanoacrylate adhesive (Krazy glue, Elmerâ€™s Products Inc.) ',...
    'was directly applied to the intact skull. A custom made headpost ',...
    'was placed on the skull with its anterior edge aligned with the suture lambda ',...
    '(approximately over cerebellum) and cemented in place ',...
    'with clear dental acrylic (Lang Dental Jet Repair Acrylic; 1223-clear). ',...
    'A thin layer of clear dental acrylic was applied over the cyanoacrylate adhesive ',...
    'covering the entire exposed skull, ',...
    'followed by a thin layer of clear nail polish (Electron Microscopy Sciences, 72180).'];
nwb.session_description = sprintf('Animal `%s` on Session `%s`', animal, session);
%% File Overview
% Each session has three files: a metadata .mat file describing the experiment, the
% data structures .mat file containing trial/analysis data, and the raw data .tar
% file containing the raw electrophysiology data separated by trial.
%% Metadata
% ALM-3 Metadata contains information about the reference times, experimental context,
% methodology, as well as details of the electrophysiology, optophysiology, and behavioral
% portions of the experiment.  A vast majority of these details will be placed in the
% _general_ subgroup in NWB.
loaded = load(metadata_loc, 'meta_data');
meta = loaded.meta_data;

%experiment-specific treatment for animals with the ReaChR gene modification
isreachr = any(cell2mat(strfind(meta.animalGeneModification, 'ReaChR')));

%sessions are separated by date of experiment.
nwb.general_session_id = meta.dateOfExperiment;

%ALM-3 data start time is reference time.
nwb.session_start_time = datetime([meta.dateOfExperiment meta.timeOfExperiment],...
    'InputFormat', 'yyyyMMddHHmmss');
nwb.timestamps_reference_time = nwb.session_start_time;

nwb.general_experimenter = strjoin(meta.experimenters, ', ');

%%
% Ideally, if a raw data field does not correspond directly to a NWB field, one would
% create their own using a
% <https://pynwb.readthedocs.io/en/latest/extensions.html custom NWB extension class>.
% To keep this tutorial simple, we instead pack the extra values into the _description_
% field as a string, which works with miscellaneous configuration parameters such as these.
nwb.general_subject = types.core.Subject(...
    'species', meta.species{1}, ...
    'subject_id', meta.animalID{1}(1,:), ... %weird case with duplicate Animal ID
    'sex', meta.sex, ...
    'age', meta.dateOfBirth, ...
    'description', [...
        'Whisker Config: ' strjoin(meta.whiskerConfig, ', ') newline...
        'Animal Source: ' strjoin(meta.animalSource, ', ')]);

%formatStruct simply prints the field and values given the struct.  Optional cell
%array of field names specifies whitelist of fields to print.
nwb.general_subject.genotype = formatStruct(...
    meta, ...
    {'animalStrain'; 'animalGeneModification'; 'animalGeneCopy';...
    'animalGeneticBackground'});

weight = {};
if ~isempty(meta.weightBefore)
    weight{end+1} = 'weightBefore';
end
if ~isempty(meta.weightAfter)
    weight{end+1} = 'weightAfter';
end
weight = weight(~cellfun('isempty', weight));
if ~isempty(weight)
    nwb.general_subject.weight = formatStruct(meta, weight);
end

% general/experiment_description
nwb.general_experiment_description = [...
    formatStruct(meta, {'experimentType'; 'referenceAtlas'}), ...
    sprintf('\n'), ...
    formatStruct(meta.behavior, {'task_keyword'})];

% Miscellaneous collection information from ALM-3 that didn't quite fit any NWB properties
% are stored in general/data_collection.
nwb.general_data_collection = formatStruct(meta.extracellular,...
    {'extracellularDataType';'cellType';'identificationMethod';'amplifierRolloff';...
    'spikeSorting';'ADunit'});

% Device objects are essentially just a list of device names.  We store the probe
% and laser hardware names here.
probetype = meta.extracellular.probeType{1};
probeSource = meta.extracellular.probeSource{1};
nwb.general_devices.set([probetype ' (' probeSource ')'],...
    types.core.Device());

if isreachr
    laserName = 'laser-594nm (Cobolt Inc., Cobolt Mambo 100)';
else
    laserName = 'laser-473nm (Laser Quantum, Gem 473)';
end
nwb.general_devices.set(laserName, types.core.Device());

%%
% The NWB *ElectrodeGroup* object stores experimental information regarding a group of
% probes (presumably defined in the *Device* section).  The object requires
% a *SoftLink* to the probe specified under _devices_.
% SoftLink objects are direct maps to
% <https://portal.hdfgroup.org/display/HDF5/H5L_CREATE_SOFT HDF5 Soft Links> on export,
% and thus, require a true HDF5 path.
structDesc = {'recordingCoordinates';'recordingMarker';'recordingType';'penetrationN';...
    'groundCoordinates'};
if ~isempty(meta.extracellular.referenceCoordinates)
    structDesc{end+1} = 'referenceCoordinates';
end
recordingLocation = meta.extracellular.recordingLocation{1};
egroup = types.core.ElectrodeGroup(...
    'description', formatStruct(meta.extracellular, structDesc),...
    'location', recordingLocation,...
    'device', types.untyped.SoftLink(['/general/devices/' probetype]));
nwb.general_extracellular_ephys.set(probetype, egroup);
egroupPath = ['/general/extracellular_ephys/' probetype];

%%
% The _electrodes_ property in _extracellular_ephys_ is a special keyword in NWB that
% must be paired with a *Dynamic Table*.  These are tables which can have an unbounded
% number of columns and rows, each as their own dataset.  With the exception of _id_,
% all columns must be *VectorData* or *VectorIndex* objects.  The _id_ column, meanwhile,
% must be an *ElementIdentifiers* object.
% The names of all used columns are specified in the in the _colnames_ property
% as a cell array of strings.
%%
% The _group_ column in the Dynamic Table contains an *ObjectView* to the ElectrodeGroup
% created above.  An ObjectView can be best thought of as a direct pointer to another
% typed object.  It also directly maps to a 
% <https://portal.hdfgroup.org/display/HDF5/H5R_CREATE HDF5 Object Reference>
% , thus the HDF5 path requirement.  ObjectViews are slightly different from SoftLinks
% in that they can be stored in datasets (data columns, tables, and _data_ fields in
% *NWBData* objects).
etrodeNum = length(meta.extracellular.siteLocations);
etrodeMat = cell2mat(meta.extracellular.siteLocations .');
emptyStr = repmat({''}, etrodeNum,1);
dtColNames = {'x', 'y', 'z', 'imp', 'location', 'description', 'filtering','group',...
    'group_name'};
% you can specify column names and values as key-value arguments in the DynamicTable
% constructor.
dynTable = types.core.DynamicTable(...
    'colnames', dtColNames,...
    'description', 'Electrodes',...
    'id', types.core.ElementIdentifiers('data', int64(1:etrodeNum)),...
    'x', types.core.VectorData('data', etrodeMat(:,1),...
        'description', 'the x coordinate of the channel location'),...
    'y', types.core.VectorData('data', etrodeMat(:,2),...
        'description', 'the y coordinate of the channel location'),...
    'z', types.core.VectorData('data', etrodeMat(:,3),...
        'description','the z coordinate of the channel location'),...
    'imp', types.core.VectorData('data', zeros(etrodeNum,1),...
        'description','the impedance of the channel'),...
    'location', types.core.VectorData('data',...
        repmat({recordingLocation}, etrodeNum, 1),...
        'description', 'the location of channel within the subject e.g. brain region'),...
    'filtering', types.core.VectorData('data', emptyStr,...
        'description', 'description of hardware filtering'),...
    'group', types.core.VectorData('data',...
        repmat(types.untyped.ObjectView(egroupPath), etrodeNum, 1),...
        'description', 'a reference to the ElectrodeGroup this electrode is a part of'),...
    'group_name', types.core.VectorData('data', repmat({probetype}, etrodeNum, 1),...
        'description', 'the name of the ElectrodeGroup this electrode is a part of'));
nwb.general_extracellular_ephys.set('electrodes', dynTable);
%%

% general/optogenetics/photostim
nwb.general_optogenetics.set('photostim', ...
    types.core.OptogeneticStimulusSite(...
    'excitation_lambda', num2str(meta.photostim.photostimWavelength{1}), ...
    'location', meta.photostim.photostimLocation{1}, ...
    'device', laserName, ...
    'description', formatStruct(meta.photostim, {...
    'stimulationMethod';'photostimCoordinates';'identificationMethod'})));

%% Data Structures and Hashes
% ALM-3 stores its data structures in the form of *Hashes* which are essentially the
% same as Dictionaries or containers.Maps but where the keys and values are stored
% under separate struct fields.  Getting a "hashed" value from a key involves retrieving
% the array index that the key is in and applying it to the parallel array in the values
% field.  In that way, it's fairly simple to convert from Hashes to equivalent Sets
% or Dynamic Tables.
%%
% You can find more information about Hashes and how they're used on the
% <https://crcns.org/data-sets/motor-cortex/alm-3/about-alm-3 ALM-3 about page>.
loaded = load(datastructure_loc, 'obj');
data = loaded.obj;

%%
% NWB comes with default support for trial-based data.  These must be *TimeIntervals* that
% are placed in the _intervals_ property in NWB.  Note that _trials_ is a special
% keyword that is required for pyNWB compatibility.
trials = types.core.TimeIntervals(...
    'start_time', types.core.VectorData('data', data.trialStartTimes,...
    'description', 'the start time of each trial'),...
    'colnames', [data.trialTypeStr; data.trialPropertiesHash.keyNames .'],...
    'description', 'trial data and properties', ...
    'id', types.core.ElementIdentifiers('data', data.trialIds));
for i=1:length(data.trialTypeStr)
    trials.vectordata.set(data.trialTypeStr{i}, ...
        types.core.VectorData('data', data.trialTypeMat(i,:),...
            'description', data.trialTypeStr{i}));
end

for i=1:length(data.trialPropertiesHash.keyNames)
    trials.vectordata.set(data.trialPropertiesHash.keyNames{i}, ...
        types.core.VectorData(...
        'data', data.trialPropertiesHash.value{i}, ...
        'description', data.trialPropertiesHash.descr{i}));
end
nwb.intervals.set('trials', trials); %MUST be called `trials` for pynwb compatibility

ephus = data.timeSeriesArrayHash.value{1};
ephusUnit = data.timeUnitNames{data.timeUnitIds(ephus.timeUnit)};

%%
% Ephus behavioral data is stored in separate NWB locations:
%
% * Lick trace data is stored in _acquisition_ under _lick_trace_
% * AOM input trace and laser power are stored in _stimulus/presentation_ as
% _aom_input_trace_ and _laser_power_ respectively.
%
% Trial IDs, wherever they are used, will be placed in a relevent _control_ property in the
% data object and will indicate what data is associated with what trial as
% defined in the trials id column.

% lick_trace
tsIdx = strcmp(ephus.idStr, 'lick_trace');
bts = types.core.BehavioralTimeSeries();
bts.timeseries.set('lick_trace_ts', ...
    types.core.TimeSeries(...
    'control', ephus.trial, ...
    'control_description', 'trial index', ...
    'data', ephus.valueMatrix(:,tsIdx),...
    'data_unit', ephusUnit,...
    'description', ephus.idStrDetailed{tsIdx}, ...
    'timestamps', ephus.time, ...
    'timestamps_unit', ephusUnit));
nwb.acquisition.set('lick_trace', bts);

% aom
tsIdx = strcmp(ephus.idStr, 'aom_input_trace');
ts = types.core.TimeSeries(...
    'control', ephus.trial, ...
    'control_description', 'trial index', ...
    'data', ephus.valueMatrix(:,tsIdx), ...
    'data_unit', 'Volts', ...
    'description', ephus.idStrDetailed{tsIdx}, ...
    'timestamps', ephus.time, ...
    'timestamps_unit', ephusUnit);
nwb.stimulus_presentation.set('aom_input_trace', ts);
% laser_power
tsIdx = strcmp(ephus.idStr, 'laser_power');
ots = types.core.OptogeneticSeries(...
    'control', ephus.trial, ...
    'control_description', 'trial index', ...
    'data', ephus.valueMatrix(:,tsIdx), ...
    'data_unit', 'mW', ...
    'description', ephus.idStrDetailed{tsIdx}, ...
    'timestamps', ephus.time, ...
    'timestamps_unit', ephusUnit, ...
    'site', types.untyped.SoftLink('/general/optogenetics/photostim'));
nwb.stimulus_presentation.set('laser_power', ots);

%%
% Ephus spike data is separated into units which directly maps to the NWB property
% of the same name.  Each such unit contains a group of analysed waveforms and spike
% times, all linked to a different subset of trials IDs.  The waveforms are placed
% in the _analysis_ Set and are paired with their unit name ('unitx' where 'x' is
% some unit ID).  The spike times and trial IDs are kept in the *Units* object (under
% the _units_ property) along with references to the _analysis_ waveforms.
% To better how _spike_times_index_ and _spike_times_ map to each other, refer to
% <https://neurodatawithoutborders.github.io/matnwb/tutorials/html/ecephys.html#13 this
% diagram> from the Extracellular Electrophysiology Tutorial.
%%
% To index the relevent trial IDs, The _trials_ column uses *RegionView* objects.
% RegionViews are ObjectViews with extra embedded indexing information which allows
% for referring to subsets of data within a dataset.
%%
% *NOTE*: To reference indices in dynamic tables such as _intervals/trials_, the raw
% HDF5 path must point to the column (_intervals/trials/id_ in this case).
nwb.units = types.core.Units('colnames',...
    {'spike_times_index', 'spike_times', 'trials', 'waveforms'},...
    'description', 'Analysed Spike Events');
esHash = data.eventSeriesHash;
ids = regexp(esHash.keyNames, '^unit(\d+)$', 'once', 'tokens');
ids = str2double([ids{:}]);
nwb.units.id = types.core.ElementIdentifiers('data', ids);
nwb.units.spike_times_index = types.core.VectorIndex(...
    'data', types.untyped.RegionView.empty,...
    'target', types.untyped.ObjectView('/units/spike_times'));
nwb.units.spike_times = types.core.VectorData(...
    'description', 'timestamps of spikes');
trials = types.core.VectorIndex(...
    'data', types.untyped.RegionView.empty,...
    'target', types.untyped.ObjectView('/intervals/trials'));
wav_idx = types.core.VectorData('data',types.untyped.ObjectView.empty,...
    'description', 'waveform references');
trial_ids = nwb.intervals.get('trials').id.data;
for i=1:length(ids)
    esData = esHash.value{i};
    trials.data(end+1) = types.untyped.RegionView('/intervals/trials/id',...
        trial_ids == esData.eventTrials);

    nwb.units.spike_times_index.data(end+1) = ...
        types.untyped.RegionView('/units/spike_times',...
        length(nwb.units.spike_times.data) + (1:length(esData.eventTimes)));
    nwb.units.spike_times.data = [nwb.units.spike_times.data;esData.eventTimes];
    
    ses = types.core.SpikeEventSeries(...
        'control', esData.eventTrials,...
        'control_description', 'trial indices', ...
        'data', esData.waveforms, ...
        'description', esHash.descr{i}, ...
        'timestamps', esData.eventTimes, ...
        'timestamps_unit', data.timeUnitNames{data.timeUnitIds(esData.timeUnit)},...
        'electrodes', types.core.DynamicTableRegion(...
            'description', 'Electrodes involved with these spike events',...
            'table', types.untyped.ObjectView('/general/extracellular_ephys/electrodes'),...
            'data', esData.channel));
    if ~isempty(esData.cellType)
        ses.comments = ['cellType: ' esData.cellType{1}];
    end
    nwb.analysis.set(esHash.keyNames{i}, ses);
    wav_idx.data(end+1) = types.untyped.ObjectView(['/analysis/' esHash.keyNames{i}]);
end
nwb.units.vectorindex.set('trials', trials);
nwb.units.vectordata.set('waveforms', wav_idx);


%% Raw Acquisition Data
% Each ALM-3 session is associated with a large number of raw voltage data grouped by
% trial ID. To map this data to NWB, each trial is created as its own *ElectricalSeries*
% object under the name 'trial n' where 'n' is the trial ID.
untarLoc = fullfile(pwd, identifier);
if 7 ~= exist(untarLoc, 'dir')
    untar(rawdata_loc, pwd);
end

rawfiles = dir(untarLoc);
rawfiles = fullfile(untarLoc, {rawfiles(~[rawfiles.isdir]).name});

nrows = length(nwb.general_extracellular_ephys.get('electrodes').id.data);
tablereg = types.core.DynamicTableRegion(...
    'description','Relevent Electrodes for this Electrical Series',...
    'table',types.untyped.ObjectView('/general/extracellular_ephys/electrodes'),...
    'data',1:nrows);
objrefs = cell(size(rawfiles));
trials = nwb.intervals.get('trials');
endTimestamps = trials.start_time.data;
for i=1:length(rawfiles)
    tnumstr = regexp(rawfiles{i}, '_trial_(\d+)\.mat$', 'tokens', 'once');
    tnumstr = tnumstr{1};
    rawdata = load(rawfiles{i}, 'ch_MUA', 'TimeStamps');
    tnum = str2double(tnumstr);
    es = types.core.ElectricalSeries(...
        'data', rawdata.ch_MUA,...
        'description', ['Raw Voltage Acquisition for trial ' tnumstr],...
        'electrodes', tablereg,...
        'timestamps', rawdata.TimeStamps);
    tname = ['trial ' tnumstr];
    nwb.acquisition.set(tname, es);
    endTimestamps(tnum) = endTimestamps(tnum) + rawdata.TimeStamps(end);
    objrefs{tnum} = types.untyped.ObjectView(['/acquisition/' tname]);
end

%we then link to the raw data by adding the acquisition column with ObjectViews
%to the data
emptyrefs = cellfun('isempty', objrefs);
objrefs(emptyrefs) = {types.untyped.ObjectView('')};
trials.colnames{end+1} = 'acquisition';
trials.vectordata.set('acquisition', types.core.VectorData(...
    'description', 'soft link to acquisition data for this trial',...
    'data', [objrefs{:}]));
trials.stop_time = types.core.VectorData(...
    'data', endTimestamps,...
    'description', 'the end time of each trial');

rmdir(untarLoc, 's');

%% Export
% Finally, we export using the 'session_animalID' notation used in the raw data files.
outDest = fullfile(outloc, [identifier '.nwb']);
nwbExport(nwb, outDest);
##### SOURCE END #####
--></body></html>